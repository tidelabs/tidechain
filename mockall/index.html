<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A powerful mock object library for Rust."><meta name="keywords" content="rust, rustlang, rust-lang, mockall"><title>mockall - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../mockall/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../mockall/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate mockall</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.11.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">mockall</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/mockall/lib.rs.html#2-1678">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A powerful mock object library for Rust.</p>
<p>Mockall provides tools to create mock versions of almost any trait
or struct. They can be used in unit tests as a stand-in for the real
object.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>There are two ways to use Mockall.  The easiest is to use
<a href="attr.automock.html"><code>#[automock]</code></a>.  It can mock most traits, or structs
that only have a single <code>impl</code> block.  For things it can’t handle, there is
<a href="macro.mock.html"><code>mock!</code></a>.</p>
<p>Whichever method is used, the basic idea is the same.</p>
<ul>
<li>Create a mock struct.  It’s name will be the same as the original, with
“Mock” prepended.</li>
<li>In your test, instantiate the mock struct with its <code>new</code> or <code>default</code>
method.</li>
<li>Set expectations on the mock struct.  Each expectation can have required
argument matchers, a required call count, and a required position in a
<a href="struct.Sequence.html"><code>Sequence</code></a>.  Each expectation must also have a return value.</li>
<li>Supply the mock object to the code that you’re testing.  It will return
the preprogrammed return values supplied in the previous step.  Any
accesses contrary to your expectations will cause a panic.</li>
</ul>
<h2 id="user-guide"><a href="#user-guide">User Guide</a></h2>
<ul>
<li><a href="#getting-started"><code>Getting started</code></a></li>
<li><a href="#static-return-values"><code>Static Return values</code></a></li>
<li><a href="#matching-arguments"><code>Matching arguments</code></a></li>
<li><a href="#call-counts"><code>Call counts</code></a></li>
<li><a href="#sequences"><code>Sequences</code></a></li>
<li><a href="#checkpoints"><code>Checkpoints</code></a></li>
<li><a href="#reference-arguments"><code>Reference arguments</code></a></li>
<li><a href="#reference-return-values"><code>Reference return values</code></a></li>
<li><a href="#impl-trait"><code>impl Trait</code></a></li>
<li><a href="#mocking-structs"><code>Mocking structs</code></a></li>
<li><a href="#generic-methods"><code>Generic methods</code></a></li>
<li><a href="#methods-with-generic-lifetimes"><code>Methods with generic lifetimes</code></a></li>
<li><a href="#generic-traits-and-structs"><code>Generic traits and structs</code></a></li>
<li><a href="#associated-types-1"><code>Associated types</code></a></li>
<li><a href="#multiple-and-inherited-traits"><code>Multiple and inherited traits</code></a></li>
<li><a href="#external-traits"><code>External traits</code></a></li>
<li><a href="#static-methods"><code>Static methods</code></a></li>
<li><a href="#modules"><code>Modules</code></a></li>
<li><a href="#foreign-functions"><code>Foreign functions</code></a></li>
<li><a href="#debug"><code>Debug</code></a></li>
<li><a href="#async-traits"><code>Async Traits</code></a></li>
<li><a href="#crate-features"><code>Crate features</code></a></li>
<li><a href="#examples"><code>Examples</code></a></li>
</ul>
<h3 id="getting-started"><a href="#getting-started">Getting Started</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mockall::<span class="kw-2">*</span>;
<span class="kw">use </span>mockall::predicate::<span class="kw-2">*</span>;
<span class="attr">#[automock]
</span><span class="kw">trait </span>MyTrait {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32) -&gt; u32;
}

<span class="kw">fn </span>call_with_four(x: <span class="kw-2">&amp;</span>MyTrait) -&gt; u32 {
    x.foo(<span class="number">4</span>)
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockMyTrait::new();
mock.expect_foo()
    .with(predicate::eq(<span class="number">4</span>))
    .times(<span class="number">1</span>)
    .returning(|x| x + <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="number">5</span>, call_with_four(<span class="kw-2">&amp;</span>mock));</code></pre></div>
<h3 id="static-return-values"><a href="#static-return-values">Static Return values</a></h3>
<p>Every expectation must have an associated return value (though when the
<strong>nightly</strong> feature is enabled expectations will automatically return the
default values of their return types, if their return types implement
<code>Default</code>.).  For methods that return a <code>static</code> value, the macros will
generate an <code>Expectation</code> struct like
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html"><code>this</code></a>.
There are two ways to set such an expectation’s return value: with a
constant
(<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.return_const"><code>return_const</code></a>)
or a closure
(<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.returning"><code>returning</code></a>).
A closure will take the method’s arguments by value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>MyTrait {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; u32;
    <span class="kw">fn </span>bar(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32, y: u32) -&gt; u32;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockMyTrait::new();
mock.expect_foo()
    .return_const(<span class="number">42u32</span>);
mock.expect_bar()
    .returning(|x, y| x + y);</code></pre></div>
<p>Additionally, constants that aren’t <code>Clone</code> can be returned with the
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.return_once"><code>return_once</code></a>
method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>NonClone();
<span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; NonClone;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
<span class="kw">let </span>r = NonClone{};
mock.expect_foo()
    .return_once(<span class="kw">move </span>|| r);</code></pre></div>
<p><code>return_once</code> can also be used for computing the return value with an
<code>FnOnce</code> closure.  This is useful for returning a non-<code>Clone</code> value and also
triggering side effects at the same time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>do_something() {}

<span class="kw">struct </span>NonClone();

<span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; NonClone;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
<span class="kw">let </span>r = NonClone{};
mock.expect_foo()
    .return_once(<span class="kw">move </span>|| {
        do_something();
        r
    });</code></pre></div>
<p>Mock objects are always <code>Send</code>.  If you need to use a return type that
isn’t, you can use the
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.return_const_st"><code>return_const_st</code></a>,
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.returning_st"><code>returning_st</code></a>,
or
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.return_once_st"><code>return_once_st</code></a>,
methods. If you need to match arguments that are not <code>Send</code>, you can use the
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.withf_st"><code>withf_st</code></a>
These take a non-<code>Send</code> object and add runtime access checks.  The wrapped
object will be <code>Send</code>, but accessing it from multiple threads will cause a
runtime panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: Rc&lt;u32&gt;) -&gt; Rc&lt;u32&gt;;   <span class="comment">// Rc&lt;u32&gt; isn&#39;t Send
</span>}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
<span class="kw">let </span>x = Rc::new(<span class="number">5</span>);
<span class="kw">let </span>argument = x.clone();
mock.expect_foo()
    .withf_st(<span class="kw">move </span>|x| <span class="kw-2">*</span>x == argument)
    .returning_st(<span class="kw">move </span>|<span class="kw">_</span>| Rc::new(<span class="number">42u32</span>));
<span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="kw-2">*</span>mock.foo(x));</code></pre></div>
<h3 id="matching-arguments"><a href="#matching-arguments">Matching arguments</a></h3>
<p>Optionally, expectations may have argument matchers set.  A matcher will
verify that the expectation was called with the expected arguments, or panic
otherwise.  A matcher is anything that implements the <a href="trait.Predicate.html"><code>Predicate</code></a> trait.
For example:</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32);
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .with(eq(<span class="number">42</span>))
    .return_const(());

mock.foo(<span class="number">0</span>);    <span class="comment">// Panics!</span></code></pre></div>
<p>See <a href="trait.Predicate.html"><code>predicate</code></a> for a list of Mockall’s builtin predicate functions.
For convenience,
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.withf"><code>withf</code></a>
is a shorthand for setting the commonly used
<a href="predicate/fn.function.html"><code>function</code></a> predicate.  The arguments to the predicate function are the
method’s arguments, <em>by reference</em>.  For example:</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32, y: u32);
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .withf(|x: <span class="kw-2">&amp;</span>u32, y: <span class="kw-2">&amp;</span>u32| x == y)
    .return_const(());

mock.foo(<span class="number">2 </span>+ <span class="number">2</span>, <span class="number">5</span>);    <span class="comment">// Panics!</span></code></pre></div>
<h4 id="matching-multiple-calls"><a href="#matching-multiple-calls">Matching multiple calls</a></h4>
<p>Matchers can also be used to discriminate between different invocations of
the same function.  Used that way, they can provide different return values
for different arguments.  The way this works is that on a method call, all
expectations set on a given method are evaluated in FIFO order.  The first
matching expectation is used.  Only if none of the expectations match does
Mockall panic.  For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32) -&gt; u32;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .with(eq(<span class="number">5</span>))
    .return_const(<span class="number">50u32</span>);
mock.expect_foo()
    .with(eq(<span class="number">6</span>))
    .return_const(<span class="number">60u32</span>);</code></pre></div>
<p>One common pattern is to use multiple expectations in order of decreasing
specificity.  The last expectation can provide a default or fallback value,
and earlier ones can be more specific.  For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>open(<span class="kw-2">&amp;</span><span class="self">self</span>, path: String) -&gt; <span class="prelude-ty">Option</span>&lt;u32&gt;;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_open()
    .with(eq(String::from(<span class="string">&quot;something.txt&quot;</span>)))
    .returning(|<span class="kw">_</span>| <span class="prelude-val">Some</span>(<span class="number">5</span>));
mock.expect_open()
    .return_const(<span class="prelude-val">None</span>);</code></pre></div>
<h3 id="call-counts"><a href="#call-counts">Call counts</a></h3>
<p>By default, every expectation is allowed to be called an unlimited number of
times.  But Mockall can optionally verify that an expectation was called a
fixed number of times, or any number of times within a given range.</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32);
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .times(<span class="number">1</span>)
    .return_const(());

mock.foo(<span class="number">0</span>);    <span class="comment">// Ok
</span>mock.foo(<span class="number">1</span>);    <span class="comment">// Panics!</span></code></pre></div>
<p>See also
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.never"><code>never</code></a> and
<a href="examples/__mock_MockFoo_Foo/__foo/struct.Expectation.html#method.times"><code>times</code></a>.</p>
<h3 id="sequences"><a href="#sequences">Sequences</a></h3>
<p>By default expectations may be matched in any order.  But it’s possible to
specify the order by using a <a href="struct.Sequence.html"><code>Sequence</code></a>.  Any expectations may be added to
the same sequence.  They don’t even need to come from the same object.</p>
<div class="example-wrap"><pre class="language-should_panic(expected = "Method sequence violation")"><code># use mockall::*;
#[automock]
trait Foo {
    fn foo(&amp;self);
}

# fn main() {
let mut seq = Sequence::new();

let mut mock1 = MockFoo::new();
mock1.expect_foo()
    .times(1)
    .in_sequence(&amp;mut seq)
    .returning(|| ());

let mut mock2 = MockFoo::new();
mock2.expect_foo()
    .times(1)
    .in_sequence(&amp;mut seq)
    .returning(|| ());

mock2.foo();    // Panics!  mock1.foo should&#39;ve been called first.
# }
</code></pre></div><h3 id="checkpoints"><a href="#checkpoints">Checkpoints</a></h3>
<p>Sometimes its useful to validate all expectations mid-test, throw them away,
and add new ones.  That’s what checkpoints do.  Every mock object has a
<code>checkpoint</code> method.  When called, it will immediately validate all methods’
expectations.  So any expectations that haven’t satisfied their call count
will panic.  Afterwards, those expectations will be cleared so you can add
new expectations and keep testing.</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>);
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .times(<span class="number">2</span>)
    .returning(|| ());

mock.foo();
mock.checkpoint();  <span class="comment">// Panics!  foo hasn&#39;t yet been called twice.</span></code></pre></div>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>);
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .times(<span class="number">1</span>)
    .returning(|| ());

mock.foo();
mock.checkpoint();
mock.foo();         <span class="comment">// Panics!  The expectation has been cleared.</span></code></pre></div>
<h3 id="reference-arguments"><a href="#reference-arguments">Reference arguments</a></h3>
<p>Mockall can mock methods with reference arguments, too.  There’s one catch:
the matcher <a href="trait.Predicate.html"><code>Predicate</code></a> will take reference arguments by value, not by
reference.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, x: <span class="kw-2">&amp;</span>u32) -&gt; u32;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
<span class="kw">let </span>e = mock.expect_foo()
    <span class="comment">// Note that x is a &amp;u32, not a &amp;&amp;u32
    </span>.withf(|x: <span class="kw-2">&amp;</span>u32| <span class="kw-2">*</span>x == <span class="number">5</span>)
    .returning(|x: <span class="kw-2">&amp;</span>u32| <span class="kw-2">*</span>x + <span class="number">1</span>);

<span class="macro">assert_eq!</span>(<span class="number">6</span>, mock.foo(<span class="kw-2">&amp;</span><span class="number">5</span>));</code></pre></div>
<h3 id="reference-return-values"><a href="#reference-return-values">Reference return values</a></h3>
<p>Mockall can also use reference return values.  There is one restriction: the
lifetime of the returned reference must be either the same as the lifetime
of the mock object, or <code>'static</code>.</p>
<p>Mockall creates different expectation types for methods that return
references.  Their API is the same as the basic <code>Expectation</code>, except for
setting return values.</p>
<p>Methods that return <code>'static</code> references work just like methods that return
any other <code>'static</code> value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Thing(u32);

<span class="attr">#[automock]
</span><span class="kw">trait </span>Container {
    <span class="kw">fn </span>get(<span class="kw-2">&amp;</span><span class="self">self</span>, i: u32) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>Thing;
}

<span class="kw">const </span>THING: Thing = Thing(<span class="number">42</span>);
<span class="kw">let </span><span class="kw-2">mut </span>mock = MockContainer::new();
mock.expect_get()
    .return_const(<span class="kw-2">&amp;</span>THING);

<span class="macro">assert_eq!</span>(<span class="number">42</span>, mock.get(<span class="number">0</span>).<span class="number">0</span>);</code></pre></div>
<p>Methods that take a <code>&amp;self</code> argument use an <code>Expectation</code> class like
<a href="examples/__mock_MockFoo_Foo/__bar/struct.Expectation.html">this</a>,
which
gets its return value from the
<a href="examples/__mock_MockFoo_Foo/__bar/struct.Expectation.html#method.return_const"><code>return_const</code></a> method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Thing(u32);

<span class="attr">#[automock]
</span><span class="kw">trait </span>Container {
    <span class="kw">fn </span>get(<span class="kw-2">&amp;</span><span class="self">self</span>, i: u32) -&gt; <span class="kw-2">&amp;</span>Thing;
}

<span class="kw">let </span>thing = Thing(<span class="number">42</span>);
<span class="kw">let </span><span class="kw-2">mut </span>mock = MockContainer::new();
mock.expect_get()
    .return_const(thing);

<span class="macro">assert_eq!</span>(<span class="number">42</span>, mock.get(<span class="number">0</span>).<span class="number">0</span>);</code></pre></div>
<p>Methods that take a <code>&amp;mut self</code> argument use an <code>Expectation</code> class like
<a href="examples/__mock_MockFoo_Foo/__baz/struct.Expectation.html">this</a>,
class, regardless of whether the return value is actually mutable.  They can
take their return value either from the
<a href="examples/__mock_MockFoo_Foo/__baz/struct.Expectation.html#method.return_var"><code>return_var</code></a>
or
<a href="examples/__mock_MockFoo_Foo/__baz/struct.Expectation.html#method.returning"><code>returning</code></a>
methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Thing(u32);

<span class="attr">#[automock]
</span><span class="kw">trait </span>Container {
    <span class="kw">fn </span>get_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>, i: u32) -&gt; <span class="kw-2">&amp;mut </span>Thing;
}

<span class="kw">let </span>thing = Thing(<span class="number">42</span>);
<span class="kw">let </span><span class="kw-2">mut </span>mock = MockContainer::new();
mock.expect_get_mut()
    .return_var(thing);

mock.get_mut(<span class="number">0</span>).<span class="number">0 </span>= <span class="number">43</span>;
<span class="macro">assert_eq!</span>(<span class="number">43</span>, mock.get_mut(<span class="number">0</span>).<span class="number">0</span>);</code></pre></div>
<p>Unsized types that are common targets for
<a href="https://doc.rust-lang.org/1.67.1/core/ops/deref/trait.Deref.html"><code>Deref</code></a>
are special.  Mockall
will automatically use the type’s owned form for the Expectation.
Currently, the
<a href="https://doc.rust-lang.org/1.67.1/core/ffi/c_str/struct.CStr.html"><code>CStr</code></a>,
<a href="https://doc.rust-lang.org/1.67.1/std/ffi/os_str/struct.OsStr.html"><code>OsStr</code></a>,
<a href="https://doc.rust-lang.org/1.67.1/std/path/struct.Path.html"><code>Path</code></a>,
<a href="https://doc.rust-lang.org/1.67.1/alloc/slice/index.html" title="std::slice"><code>Slice</code></a>,
and
<a href="https://doc.rust-lang.org/1.67.1/alloc/str/index.html"><code>str</code></a>
types are supported.  Using this feature is automatic:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>name(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>str;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_name().return_const(<span class="string">&quot;abcd&quot;</span>.to_owned());
<span class="macro">assert_eq!</span>(<span class="string">&quot;abcd&quot;</span>, mock.name());</code></pre></div>
<p>Similarly, Mockall will use a Boxed trait object for the Expectation of
methods that return references to trait objects.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>name(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="kw">dyn </span>Display;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_name().return_const(Box::new(<span class="string">&quot;abcd&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;abcd&quot;</span>, <span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, mock.name()));</code></pre></div>
<h3 id="impl-trait"><a href="#impl-trait">Impl Trait</a></h3>
<p>Rust 1.26.0 introduced the <code>impl Trait</code> feature.  It allows functions to
return concrete but unnamed types (and, less usefully, to take them as
arguments).  It’s <em>almost</em> the same as <code>Box&lt;dyn Trait&gt;</code> but without the
extra allocation.  Mockall supports deriving mocks for methods that return
<code>impl Trait</code>, with limitations.  When you derive the mock for such a method,
Mockall internally transforms the Expectation’s return type to <code>Box&lt;dyn Trait&gt;</code>, without changing the mock method’s signature.  So you can use it
like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Foo {}
<span class="attr">#[automock]
</span><span class="kw">impl </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw">impl </span>Debug {
        <span class="comment">// ...
    </span>}
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .returning(|| Box::new(String::from(<span class="string">&quot;Hello, World!&quot;</span>)));
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, mock.foo());</code></pre></div>
<p>However, <code>impl Trait</code> isn’t <em>exactly</em> equivalent to <code>Box&lt;dyn Trait&gt;</code> but
with fewer allocations.  There are some things the former can do but the
latter can’t.  For one thing, you can’t build a trait object out of a
<code>Sized</code> trait.  So this won’t work:</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Foo {}
<span class="attr">#[automock]
</span><span class="kw">impl </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw">impl </span>Clone {
        <span class="comment">// ...
    </span>}
}</code></pre></div>
<p>Nor can you create a trait object that implements two or more non-auto
types.  So this won’t work either:</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Foo {}
<span class="attr">#[automock]
</span><span class="kw">impl </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw">impl </span>Debug + Display {
        <span class="comment">// ...
    </span>}
}</code></pre></div>
<p>For such cases, there is no magic bullet.  The best way to mock methods like
those would be to refactor them to return named (but possibly opaque) types
instead.</p>
<p>See Also <a href="https://rust-lang-nursery.github.io/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease"><code>impl-trait-for-returning-complex-types-with-ease.html</code></a></p>
<h4 id="impl-future"><a href="#impl-future">impl Future</a></h4>
<p>Rust 1.36.0 added the <code>Future</code> trait.  Unlike virtually every trait that
preceeded it, <code>Box&lt;dyn Future&gt;</code> is mostly useless.  Instead, you usually
need a <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>.  So that’s what Mockall will do when you mock
a method returning <code>impl Future</code> or the related <code>impl Stream</code>.  Just
remember to use <code>pin</code> in your expectations, like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Foo {}
<span class="attr">#[automock]
</span><span class="kw">impl </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw">impl </span>Future&lt;Output=i32&gt; {
        <span class="comment">// ...
    </span>}
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .returning(|| Box::pin(future::ready(<span class="number">42</span>)));</code></pre></div>
<h3 id="mocking-structs"><a href="#mocking-structs">Mocking structs</a></h3>
<p>Mockall mocks structs as well as traits.  The problem here is a namespace
problem: it’s hard to supply the mock object to your code under test,
because it has a different name.  The solution is to alter import paths
during test.  The easiest way to do that is with the
<a href="https://docs.rs/mockall_double/latest"><code>mockall_double</code></a> crate.</p>
<p><a href="attr.automock.html"><code>#[automock]</code></a>
works for structs that have a single <code>impl</code> block:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mockall_double::double;
<span class="kw">mod </span>thing {
    <span class="kw">use </span>mockall::automock;
    <span class="kw">pub struct </span>Thing{}
    <span class="attr">#[automock]
    </span><span class="kw">impl </span>Thing {
        <span class="kw">pub fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; u32 {
            <span class="comment">// ...
        </span>}
    }
}

<span class="attr">#[double]
</span><span class="kw">use </span>thing::Thing;

<span class="kw">fn </span>do_stuff(thing: <span class="kw-2">&amp;</span>Thing) -&gt; u32 {
    thing.foo()
}

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>t {
    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="attr">#[test]
    </span><span class="kw">fn </span>test_foo() {
        <span class="kw">let </span><span class="kw-2">mut </span>mock = Thing::default();
        mock.expect_foo().returning(|| <span class="number">42</span>);
        do_stuff(<span class="kw-2">&amp;</span>mock);
    }
}</code></pre></div>
<p>For structs with more than one <code>impl</code> block or that have unsupported
<code>#[derive(X)]</code> attributes, e.g. <code>Clone</code>, see <a href="macro.mock.html"><code>mock!</code></a> instead.</p>
<h3 id="generic-methods"><a href="#generic-methods">Generic methods</a></h3>
<p>Generic methods can be mocked, too.  Effectively each generic method is an
infinite set of regular methods, and each of those works just like any other
regular method.  The expect_* method is generic, too, and usually must be
called with a turbofish.  The only restrictions on mocking generic methods
are that all generic parameters must be <code>'static</code>, and generic lifetime
parameters are not allowed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo&lt;T: <span class="lifetime">&#39;static</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, t: T) -&gt; i32;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo::&lt;i16&gt;()
    .returning(|t| i32::from(t));
mock.expect_foo::&lt;i8&gt;()
    .returning(|t| -i32::from(t));

<span class="macro">assert_eq!</span>(<span class="number">5</span>, mock.foo(<span class="number">5i16</span>));
<span class="macro">assert_eq!</span>(-<span class="number">5</span>, mock.foo(<span class="number">5i8</span>));</code></pre></div>
<h3 id="methods-with-generic-lifetimes"><a href="#methods-with-generic-lifetimes">Methods with generic lifetimes</a></h3>
<p>A method with a lifetime parameter is technically a generic method, but
Mockall treats it like a non-generic method that must work for all possible
lifetimes.  Mocking such a method is similar to mocking a non-generic
method, with a few additional restrictions.  One restriction is that you
can’t match calls with <code>with</code>, you must use <code>withf</code> instead.  Another is
that the generic lifetime may not appear as part of the return type.
Finally, no method may have both generic lifetime parameters <em>and</em> generic
type parameters.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>X&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>i32);

<span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, x: X&lt;<span class="lifetime">&#39;a</span>&gt;) -&gt; i32;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo()
    .withf(|f| <span class="kw-2">*</span>f.<span class="number">0 </span>== <span class="number">5</span>)
    .return_const(<span class="number">42</span>);
<span class="kw">let </span>x = X(<span class="kw-2">&amp;</span><span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="number">42</span>, mock.foo(x));</code></pre></div>
<h3 id="generic-traits-and-structs"><a href="#generic-traits-and-structs">Generic traits and structs</a></h3>
<p>Mocking generic structs and generic traits is not a problem.  The mock
struct will be generic, too.  The same restrictions apply as with mocking
generic methods: each generic parameter must be <code>'static</code>, and generic
lifetime parameters are not allowed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo&lt;T: <span class="lifetime">&#39;static</span>&gt; {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, t: T) -&gt; i32;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::&lt;i16&gt;::new();
mock.expect_foo()
    .returning(|t| i32::from(t));
<span class="macro">assert_eq!</span>(<span class="number">5</span>, mock.foo(<span class="number">5i16</span>));</code></pre></div>
<h3 id="associated-types"><a href="#associated-types">Associated types</a></h3>
<p>Traits with associated types can be mocked too.  Unlike generic traits, the
mock struct will not be generic.  Instead, you must specify the associated
types when defining the mock struct.  They’re specified as metaitems to the
<a href="attr.automock.html"><code>#[automock]</code></a> attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock(<span class="kw">type </span>Key=u16; <span class="kw">type </span>Value=i32;)]
</span><span class="kw">pub trait </span>A {
    <span class="kw">type </span>Key;
    <span class="kw">type </span>Value;
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>, k: <span class="self">Self</span>::Key) -&gt; <span class="self">Self</span>::Value;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockA::new();
mock.expect_foo()
    .returning(|x: u16| i32::from(x));
<span class="macro">assert_eq!</span>(<span class="number">4</span>, mock.foo(<span class="number">4</span>));</code></pre></div>
<h3 id="multiple-and-inherited-traits"><a href="#multiple-and-inherited-traits">Multiple and inherited traits</a></h3>
<p>Creating a mock struct that implements multiple traits, whether inherited or
not, requires using the <a href="macro.mock.html"><code>mock!</code></a> macro.  But once created,
using it is just the same as using any other mock object:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub trait </span>A {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>);
}

<span class="kw">pub trait </span>B: A {
    <span class="kw">fn </span>bar(<span class="kw-2">&amp;</span><span class="self">self</span>);
}

<span class="macro">mock! </span>{
    <span class="comment">// Structure to mock
    </span>C {}
    <span class="comment">// First trait to implement on C
    </span><span class="kw">impl </span>A <span class="kw">for </span>C {
        <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>);
    }
    <span class="comment">// Second trait to implement on C
    </span><span class="kw">impl </span>B <span class="kw">for </span>C {
        <span class="kw">fn </span>bar(<span class="kw-2">&amp;</span><span class="self">self</span>);
    }
}
<span class="kw">let </span><span class="kw-2">mut </span>mock = MockC::new();
mock.expect_foo().returning(|| ());
mock.expect_bar().returning(|| ());
mock.foo();
mock.bar();</code></pre></div>
<h3 id="external-traits"><a href="#external-traits">External traits</a></h3>
<p>Mockall can mock traits and structs defined in external crates that are
beyond your control, but you must use <a href="macro.mock.html"><code>mock!</code></a> instead of
<a href="attr.automock.html"><code>#[automock]</code></a>.  Mock an external trait like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">mock! </span>{
    MyStruct {}     <span class="comment">// Name of the mock struct, less the &quot;Mock&quot; prefix
    </span><span class="kw">impl </span>Clone <span class="kw">for </span>MyStruct {   <span class="comment">// specification of the trait to mock
        </span><span class="kw">fn </span>clone(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self</span>;
    }
}

<span class="kw">let </span><span class="kw-2">mut </span>mock1 = MockMyStruct::new();
<span class="kw">let </span>mock2 = MockMyStruct::new();
mock1.expect_clone()
    .return_once(<span class="kw">move </span>|| mock2);
<span class="kw">let </span>cloned = mock1.clone();</code></pre></div>
<h3 id="static-methods"><a href="#static-methods">Static methods</a></h3>
<p>Mockall can also mock static methods.  But be careful!  The expectations are
global.  If you want to use a static method in multiple tests, you must
provide your own synchronization. See the <a href="https://github.com/asomers/mockall/blob/master/mockall/examples/synchronization.rs"><code>synchronization example</code></a>
for a basic implementation. For ordinary methods, expectations are
set on the mock object.  But static methods don’t have any mock object.
Instead, you must create a <code>Context</code> object just to set their expectations.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">pub trait </span>A {
    <span class="kw">fn </span>foo() -&gt; u32;
}

<span class="kw">let </span>ctx = MockA::foo_context();
ctx.expect().returning(|| <span class="number">99</span>);
<span class="macro">assert_eq!</span>(<span class="number">99</span>, MockA::foo());</code></pre></div>
<p>A common pattern is mocking a trait with a constructor method.  In this case,
you can easily set the mock constructor method to return a mock object.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Foo{}
<span class="attr">#[automock]
</span><span class="kw">impl </span>Foo {
    <span class="kw">fn </span>from_i32(x: i32) -&gt; <span class="self">Self </span>{
        <span class="comment">// ...
    </span>}
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; i32 {
        <span class="comment">// ...
    </span>}
}

<span class="kw">let </span>ctx = MockFoo::from_i32_context();
ctx.expect()
    .returning(|x| {
        <span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::default();
        mock.expect_foo()
            .return_const(x);
        mock
    });
<span class="kw">let </span>foo = MockFoo::from_i32(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(<span class="number">42</span>, foo.foo());</code></pre></div>
<h4 id="generic-static-methods"><a href="#generic-static-methods">Generic static methods</a></h4>
<p>Mocking static methods of generic structs or traits, whether or not the
methods themselves are generic, should work seamlessly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo&lt;T: <span class="lifetime">&#39;static</span>&gt; {
    <span class="kw">fn </span>new(t: T) -&gt; MockFoo&lt;T&gt;;
}

<span class="kw">let </span>ctx = MockFoo::&lt;u32&gt;::new_context();
ctx.expect()
    .returning(|<span class="kw">_</span>| MockFoo::default());
<span class="kw">let </span>mock = MockFoo::&lt;u32&gt;::new(<span class="number">42u32</span>);</code></pre></div>
<h4 id="context-checkpoints"><a href="#context-checkpoints">Context checkpoints</a></h4>
<p>The context object cleans up all expectations when it leaves scope.  It also
has a <code>checkpoint</code> method that functions just like a mock object’s
<code>checkpoint</code> method.</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">pub trait </span>A {
    <span class="kw">fn </span>foo() -&gt; u32;
}

<span class="kw">let </span>ctx = MockA::foo_context();
ctx.expect()
    .times(<span class="number">1</span>)
    .returning(|| <span class="number">99</span>);
ctx.checkpoint();   <span class="comment">// Panics!</span></code></pre></div>
<p>A mock object’s checkpoint method does <em>not</em> checkpoint static methods.
This behavior is useful when using multiple mock objects at once.  For
example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">pub trait </span>A {
    <span class="kw">fn </span>build() -&gt; <span class="self">Self</span>;
    <span class="kw">fn </span>bar(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; i32;
}

<span class="kw">let </span>ctx = MockA::build_context();
ctx.expect()
    .times(<span class="number">2</span>)
    .returning(|| MockA::default());
<span class="kw">let </span><span class="kw-2">mut </span>mock0 = MockA::build();
mock0.expect_bar().return_const(<span class="number">4</span>);
mock0.bar();
mock0.checkpoint();     <span class="comment">// Does not checkpoint the build method
</span><span class="kw">let </span>mock1 = MockA::build();</code></pre></div>
<p>One more thing: Mockall normally creates a zero-argument <code>new</code> method for
every mock struct.  But it <em>won’t</em> do that when mocking a struct that
already has a method named <code>new</code>.  The <code>default</code> method will still be
present.</p>
<h3 id="modules"><a href="#modules">Modules</a></h3>
<p>In addition to mocking types, Mockall can also derive mocks for
entire modules of Rust functions.  Mockall will generate a new module named
“mock_xxx”, if “xxx” is the original module’s name.  You can also use
<code>#[double]</code> to selectively import the mock module.</p>
<p>Be careful!  Module functions are static and so have the same caveats as
<a href="#static-methods">static methods</a> described above.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>outer {
    <span class="kw">use </span>mockall::automock;
    <span class="attr">#[automock()]
    </span><span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">mod </span>inner {
        <span class="kw">pub fn </span>bar(x: u32) -&gt; i64 {
            <span class="comment">// ...
        </span>}
    }
}

<span class="attr">#[double]
</span><span class="kw">use </span>outer::inner;

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>t {
    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="attr">#[test]
    </span><span class="kw">fn </span>test_foo_bar() {
        <span class="kw">let </span>ctx = inner::bar_context();
        ctx.expect()
            .returning(|x| i64::from(x + <span class="number">1</span>));
        <span class="macro">assert_eq!</span>(<span class="number">5</span>, inner::bar(<span class="number">4</span>));
    }
}</code></pre></div>
<h4 id="foreign-functions"><a href="#foreign-functions">Foreign functions</a></h4>
<p>One reason to mock modules is when working with foreign functions.  Modules
may contain foreign functions, even though structs and traits may not.  Like
static methods, the expectations are global.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>outer {
    <span class="attr">#[automock]
    </span><span class="kw">pub mod </span>ffi {
        <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
            <span class="kw">pub fn </span>foo(x: u32) -&gt; i64;
        }
    }
}

<span class="attr">#[double]
</span><span class="kw">use </span>outer::ffi;

<span class="kw">fn </span>do_stuff() -&gt; i64 {
    <span class="kw">unsafe</span>{ ffi::foo(<span class="number">42</span>) }
}

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>t {
    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="attr">#[test]
    </span><span class="kw">fn </span>test_foo() {
        <span class="kw">let </span>ctx = ffi::foo_context();
        ctx.expect()
            .returning(|x| i64::from(x + <span class="number">1</span>));
        <span class="macro">assert_eq!</span>(<span class="number">43</span>, do_stuff());
    }
}</code></pre></div>
<h3 id="debug"><a href="#debug">Debug</a></h3>
<p><code>#[automock]</code> will automatically generate <code>Debug</code> impls when mocking traits
and struct impls.  <code>mock!</code> will too, if you add a <code>#[derive(Debug)]</code>, like
this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">mock! </span>{
    <span class="attr">#[derive(Debug)]
    </span><span class="kw">pub </span>Foo {}
}</code></pre></div>
<h3 id="async-traits"><a href="#async-traits">Async Traits</a></h3>
<p>Async traits aren’t yet (as of 1.47.0) a part of the Rust language.  But
they’re available from the
<a href="https://docs.rs/async-trait/0.1.38/async_trait/"><code>async_trait</code></a> crate.
Mockall is compatible with this crate, with two important limitations:</p>
<ul>
<li>
<p>The <code>#[automock]</code> attribute must appear <em>before</em> the <code>#[async_trait]</code>
attribute.</p>
</li>
<li>
<p>The <code>#[async_trait]</code> macro must be imported with its canonical name.</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// async_trait works with both #[automock]
</span><span class="attr">#[automock]
#[async_trait]
</span><span class="kw">pub trait </span>Foo {
   <span class="kw">async fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; u32;
}
<span class="comment">// and mock!
</span><span class="macro">mock! </span>{
    <span class="kw">pub </span>Bar {}
    <span class="attr">#[async_trait]
    </span><span class="kw">impl </span>Foo <span class="kw">for </span>Bar {
        <span class="kw">async fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; u32;
    }
}</code></pre></div>
<h3 id="crate-features"><a href="#crate-features">Crate features</a></h3>
<p>Mockall has a <strong>nightly</strong> feature.  Currently this feature has two
effects:</p>
<ul>
<li>
<p>The compiler will produce better error messages.</p>
</li>
<li>
<p>Expectations for methods whose return type implements <code>Default</code> needn’t
have their return values explicitly set.  Instead, they will automatically
return the default value.</p>
</li>
</ul>
<p>With <strong>nightly</strong> enabled, you can omit the return value like this:</p>

<div class="example-wrap should_panic"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[automock]
</span><span class="kw">trait </span>Foo {
    <span class="kw">fn </span>foo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;u32&gt;;
}

<span class="kw">let </span><span class="kw-2">mut </span>mock = MockFoo::new();
mock.expect_foo();
<span class="macro">assert!</span>(mock.foo().is_empty());</code></pre></div>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>For additional examples of Mockall in action, including detailed
documentation on the autogenerated methods, see
<a href="examples/index.html"><code>examples</code></a>.</p>
</div></details><h2 id="modules-1" class="small-section-header"><a href="#modules-1">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="examples/index.html" title="mockall::examples mod">examples</a></div><div class="item-right docblock-short">Examples of Mockall’s generated code</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="predicate/index.html" title="mockall::predicate mod">predicate</a></div><div class="item-right docblock-short">Predicate factories</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.mock.html" title="mockall::mock macro">mock</a></div><div class="item-right docblock-short">Manually mock a structure.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Sequence.html" title="mockall::Sequence struct">Sequence</a></div><div class="item-right docblock-short">Used to enforce that mock calls must happen in the sequence specified.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Predicate.html" title="mockall::Predicate trait">Predicate</a></div><div class="item-right docblock-short">Trait for generically evaluating a type against a dynamically created
predicate function.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.PredicateBooleanExt.html" title="mockall::PredicateBooleanExt trait">PredicateBooleanExt</a></div><div class="item-right docblock-short"><code>Predicate</code> extension that adds boolean logic.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.PredicateBoxExt.html" title="mockall::PredicateBoxExt trait">PredicateBoxExt</a></div><div class="item-right docblock-short"><code>Predicate</code> extension for boxing a <code>Predicate</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.PredicateFileContentExt.html" title="mockall::PredicateFileContentExt trait">PredicateFileContentExt</a></div><div class="item-right docblock-short"><code>Predicate</code> extension adapting a <code>slice</code> Predicate.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.PredicateStrExt.html" title="mockall::PredicateStrExt trait">PredicateStrExt</a></div><div class="item-right docblock-short"><code>Predicate</code> extension adapting a <code>str</code> Predicate.</div></div></div><h2 id="attributes" class="small-section-header"><a href="#attributes">Attribute Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="attr" href="attr.automock.html" title="mockall::automock attr">automock</a></div><div class="item-right docblock-short">Automatically generate mock types for structs and traits.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="mockall" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>