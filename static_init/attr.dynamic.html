<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Declare statics that can be initialized with non const fonctions and safe mutable statics"><meta name="keywords" content="rust, rustlang, rust-lang, dynamic"><title>dynamic in static_init - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../static_init/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../static_init/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In static_init</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Attribute Macro <a href="index.html">static_init</a>::<wbr><a class="attr" href="#">dynamic</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/static_init_macro/lib.rs.html#134">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust attr"><code>#[dynamic]</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Declare statics that can be initialized with non const fonctions and safe mutable statics</p>
<p>Statics on which this attribute is applied will be be initialized at run time (optionaly see
bellow), before main start. This allow statics initialization with non const expressions.</p>
<p>There are two main categories of statics:</p>
<ul>
<li>
<p><em>lazy statics</em> which are statics that are always safe to use. They may be initialized on
first acces or before main is called;</p>
</li>
<li>
<p><em>locked lazy statics</em> which are the mutable version of lazy statics.</p>
</li>
<li>
<p><em>raw statics</em>, which are initialized at program start-up and absolutely unchecked. Any
access to them requires <code>unsafe</code> block;</p>
</li>
</ul>
<h2 id="lazy-statics"><a href="#lazy-statics">Lazy statics</a></h2>
<p>Those statics are initialized on first access. An optimization implemented by <em>lesser lazy statics</em>
initialize the static before main is called on all tier1 plateform but mach.</p>
<p>The declared object is encapsulated in a type that implement <code>Deref</code>.</p>
<p>Other access functionnality and state information are accessible through the <code>LazyAccess</code>
trait.</p>
<p>Those lazy can be used with regular statics and thread locals.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[dynamic]
</span><span class="kw">static </span>A :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="attr">#[dynamic]
#[thread_local]
</span><span class="kw">static </span>TL :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];
</code></pre></div>
<h3 id="lesser-lazy-statics"><a href="#lesser-lazy-statics">Lesser Lazy Statics</a></h3>
<p>They are declared with the <code>#[dynamic]</code> attribute (or equivalently <code>#[dynamic(lesser_lazy)]</code>.
They are either initialized on first access or before main is called. They provide
unsurpassable access performance: their access time is comparable to const initialized statics
but they support non const initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynamic]
</span><span class="kw">static </span>V :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="macro">assert_eq!</span>(V.len(), <span class="number">2</span>);</code></pre></div>
<h3 id="realy-lazy-statics"><a href="#realy-lazy-statics">Realy lazy Statics</a></h3>
<p>When initialization on first access is a requirement, the static shall be attributed with
<code>#[dynamic(lazy)]</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynamic(lazy)]
</span><span class="kw">static </span>V :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>V, <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>]);</code></pre></div>
<h3 id="finalized-statics"><a href="#finalized-statics">Finalized statics</a></h3>
<p>The attribute argument <code>finalize</code> can be used if the declared type of
the static implement <code>Finaly</code> trait. The finalize method is called at
program exit or at thread exit for thread locals. (NB: mutable lazy also
support drop, see below)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>

<span class="kw">struct </span>A(i32);

<span class="kw">impl </span>Finaly <span class="kw">for </span>A {
    <span class="kw">fn </span>finaly(<span class="kw-2">&amp;</span><span class="self">self</span>){<span class="comment">/* some clean up code */ </span>}
}

<span class="attr">#[dynamic(finalize)] </span><span class="comment">//finalize execute at program exit
</span><span class="kw">static </span>X :A = A(<span class="number">33</span>);

<span class="attr">#[dynamic(lazy,finalize)] </span><span class="comment">//finalize executed at thread exit
</span><span class="attr">#[thread_local]
</span><span class="kw">static </span>Y :A = A(<span class="number">33</span>);</code></pre></div>
<h3 id="tolerances"><a href="#tolerances">Tolerances</a></h3><h4 id="initialization-fault-tolerance"><a href="#initialization-fault-tolerance">Initialization fault tolerance</a></h4>
<p>By default if the initialization of a lazy panic, initialization will be attempted
once again on the next access attempt. If this is not desired the lazy should be declared
with attribute argument <code>try_init_once</code>, in which case, the lazy will be poisonned if
initialization panics.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynamic(try_init_once)]
</span><span class="kw">static </span>X :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="attr">#[dynamic(lazy,try_init_once)] </span><span class="comment">//attribute argument can be combined
</span><span class="kw">static </span>Y :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];</code></pre></div>
<h4 id="registration-for-finalization-tolerance"><a href="#registration-for-finalization-tolerance">Registration for finalization tolerance</a></h4>
<p>By default lazy that intended to be finalized (because they use the <code>finalize</code> or <code>drop</code>
attribute argument) refuse to initialize if registration of the finalization or drop at
program exit or thread exit fails.</p>
<p>If this is not desired, the <code>tolerate_leak</code> attribute argument can be used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A(i32);

<span class="kw">impl </span>Finaly <span class="kw">for </span>A {
    <span class="kw">fn </span>finaly(<span class="kw-2">&amp;</span><span class="self">self</span>){<span class="comment">/* some clean up code */ </span>}
}

<span class="attr">#[dynamic(finalize,tolerate_leak)]
</span><span class="kw">static </span>X :A = A(<span class="number">21</span>);
<span class="comment">//the initialization may succeed even if it is impossible to register
//the call to finaly at program exit</span></code></pre></div>
<h2 id="locked-lazy-statics"><a href="#locked-lazy-statics">Locked lazy statics</a></h2>
<p>Those statics are mutable statics, initialized on the first acces and protected behind
a kind of read/write lock specialy designed for them.</p>
<p>The are declared as <em>lazy statics</em> but with the <code>mut</code> keyword. The macro will actualy remove
the <code>mut</code> keyword and use a r/w locked wrapper type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[dynamic]
</span><span class="kw">static </span><span class="kw-2">mut </span>V: Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

V.write().push(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>V.read(), <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</code></pre></div>
<p>Those statics provides different methods to access the target object. See the documentation of
<a href="struct.LockedLazy.html" title="LockedLazy">LockedLazy</a> for exemple. All <em>locked lazy</em> types provide the same methods.</p>
<p>Locked lazy statics support all attribute arguments supported by <em>lazy statics</em>: <code>finalize</code>,
<code>try_init_once</code>, <code>tolerate_leak</code>. Moreover they support two other arguments:</p>
<ul>
<li><code>drop</code> in which case the static will be dropped at program exit:</li>
<li><code>prime</code> which is a static that support access before it is actualy initialized
and after it is droped;</li>
</ul>
<h3 id="dropped-locked-lazy-statics"><a href="#dropped-locked-lazy-statics">Dropped locked lazy statics</a></h3>
<p>Locked lazy statics can be droped at program exit or thread exit when declared with
the <code>drop</code> attribute argument</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>


<span class="attr">#[dynamic(drop)]
#[thread_local]
</span><span class="kw">static </span><span class="kw-2">mut </span>V: Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="attr">#[dynamic(lazy,drop,tolerate_leak)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V2: Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];</code></pre></div>
<h3 id="primed-locked-lazy-statics"><a href="#primed-locked-lazy-statics">Primed locked lazy statics</a></h3>
<p>Those statics model the case where an object should have a
standard behavior and a fallback behavior after ressources
are release or not yet acquired.</p>
<p>Those statics are initialized in two steps:</p>
<ul>
<li>
<p>a const initialization that happens at compile time</p>
</li>
<li>
<p>a dynamic intialization that happens the first time they are accessed if
if is declared with <code>lazy</code> attribute argument or just before.</p>
</li>
</ul>
<p>More over they are conceptualy uninitialized if the type of the statics
implement the <code>Uninit</code> trait and is declared with the <code>drop</code> attribute argument.</p>
<p>They must be initialized with a match expression as exemplified bellow:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>static_init::{dynamic, Uninit};

<span class="attr">#[dynamic(prime)]
</span><span class="kw">static </span><span class="kw-2">mut </span>O: <span class="prelude-ty">Option</span>&lt;Vec&lt;i32&gt;&gt; = <span class="kw">match </span>INIT {
    PRIME =&gt; <span class="prelude-val">None</span>,
    DYN =&gt; <span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>]),
    };

<span class="attr">#[dynamic(lazy,prime)]
</span><span class="kw">static </span><span class="kw-2">mut </span>OLAZY: <span class="prelude-ty">Option</span>&lt;Vec&lt;i32&gt;&gt; = <span class="kw">match </span>INIT {
    PRIME =&gt; <span class="prelude-val">None</span>,
    DYN =&gt; <span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>]),
    };


<span class="kw">struct </span>A(<span class="prelude-ty">Option</span>&lt;Vec&lt;i32&gt;&gt;);

<span class="kw">impl </span>Uninit <span class="kw">for </span>A {
    <span class="kw">fn </span>uninit(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="self">self</span>.<span class="number">0</span>.take();
    }
}

<span class="attr">#[dynamic(prime,finalize)]</span><span class="comment">//finalize/drop actualy means uninit for primed lazy
</span><span class="kw">static </span><span class="kw-2">mut </span>P: A = <span class="kw">match </span>INIT {
    PRIME =&gt; A(<span class="prelude-val">None</span>),
    DYN =&gt; A(<span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>])),
    };

<span class="kw">match </span>P.primed_read() {
    <span class="prelude-val">Ok</span>(read_lock) =&gt; (),<span class="comment">/*a read lock that refers to the initialized statics */
    </span><span class="prelude-val">Err</span>(read_lock) =&gt; (),<span class="comment">/* post finalization access, uninit has already been called*/
    </span>}

<span class="kw">match </span>P.primed_write() {
    <span class="prelude-val">Ok</span>(write_lock) =&gt; (),<span class="comment">/*a write lock that refers to the initialized statics */
    </span><span class="prelude-val">Err</span>(read_lock) =&gt; (),<span class="comment">/* post finalization access, uninit has already been called*/
    </span>}</code></pre></div>
<h2 id="raw-statics"><a href="#raw-statics">Raw statics</a></h2>
<p>Those statics will be initialized at program startup, without ordering, accept between those
that have different priorities on plateform that support priorities. Those statics are
supported on unixes and windows with priorities and mac without priorities.</p>
<h3 id="safety"><a href="#safety">Safety</a></h3>
<p>During initialization, any access to other
“dynamic” statics initialized with a lower priority will cause undefined behavior. Similarly,
during drop any access to a “dynamic” static dropped with a lower priority will cause undefined
behavior. For this reason those statics are always turn into mutable statics to ensure that all
access attempt is unsafe.</p>
<p>Those statics are interesting only to get the optimalest performance at the price of unsafety.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynamic(<span class="number">0</span>)]
</span><span class="kw">static </span>V :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="macro">assert!</span>(<span class="kw">unsafe</span>{<span class="kw-2">*</span>V == <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>]})</code></pre></div>
<h3 id="execution-order"><a href="#execution-order">Execution Order</a></h3>
<p>The execution order of raw static initializations is unspecified. Nevertheless on ELF plateform (linux,any unixes but mac) and
windows plateform a priority can be specified using the syntax <code>dynamic(&lt;num&gt;)</code> where
<code>&lt;num&gt;</code> is a number included in the range [0 ; 2<sup>16</sup>-1].</p>
<p>Statics with priority number 65535 are initialized first (in unspecified order), then statics
with priority number 65534 are initialized …  then statics
with priority number 0.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//V1 must be initialized first
//because V2 uses the value of V1.

</span><span class="attr">#[dynamic(<span class="number">20</span>)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V1 :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="attr">#[dynamic(<span class="number">10</span>)]
</span><span class="kw">static </span>V2 :Vec&lt;i32&gt; = <span class="kw">unsafe</span>{V1.push(<span class="number">3</span>); V1.clone()};</code></pre></div>
<h3 id="drop"><a href="#drop">Drop</a></h3>
<p>Those statics can use the <code>drop</code> attribute argument. In this case
the static will be droped at program exit</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[dynamic(<span class="number">0</span>, drop)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V1 :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];</code></pre></div>
<p>The drop priority can be specified with the <code>drop=&lt;priority&gt;</code> syntax. If no priority
is given, the drop priority will equal the one of the initialization priority.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[dynamic(<span class="number">10</span>, drop)] </span><span class="comment">//equivalent to #[dynamic(10,drop=10)]
//or longer #[dynamic(init=10,drop=10)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V1 :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];

<span class="attr">#[dynamic(<span class="number">42</span>, drop=<span class="number">33</span>)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V2 :Vec&lt;i32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>,<span class="number">2</span>];</code></pre></div>
<p>The drop priorities are sequenced in the reverse order of initialization priority. The smaller
is the priority the sooner is droped the static.</p>
<p>Finaly the <code>drop_only=&lt;priority&gt;</code> is equivalent to <code>#[dynamic(0,drop=&lt;priority&gt;)]</code> except that the
static will be const initialized.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A;
<span class="kw">impl </span>Drop <span class="kw">for </span>A {
  <span class="kw">fn </span>drop(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {}
  }

<span class="attr">#[dynamic(drop_only=<span class="number">33</span>)]
</span><span class="kw">static </span>V2: A = A;</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="static_init" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>