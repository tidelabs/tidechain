#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub mod weights;
pub use weights::*;

// Re-export pallet items so that they can be accessed from the crate namespace.
pub use pallet::*;

#[frame_support::pallet]
pub mod pallet {
  use super::*;
  use frame_support::{
    inherent::Vec,
    pallet_prelude::*,
    traits::tokens::fungibles::{Inspect, Mutate, Transfer},
    transactional, PalletId,
  };
  use frame_system::pallet_prelude::*;
  use sp_runtime::{
    traits::{AccountIdConversion, AtLeast32BitUnsigned, CheckedAdd, CheckedDiv},
    ArithmeticError, FixedPointNumber, FixedPointOperand, FixedU128, SaturatedConversion,
  };
  use tidefi_primitives::assets::AssetId;

  type AssetIdOf<T> =
    <<T as Config>::Assets as Inspect<<T as frame_system::Config>::AccountId>>::AssetId;

  type BalanceOf<T> =
    <<T as Config>::Assets as Inspect<<T as frame_system::Config>::AccountId>>::Balance;

  /// Request id generated by the contract
  type RequestId = u32;

  /// Token id
  type TokenId = u32;

  /// Timestamp
  type Timestamp = u64;

  /// Exchange rate
  type Rate = FixedU128;

  #[cfg_attr(feature = "std", derive(serde::Deserialize, serde::Serialize))]
  #[derive(Encode, Decode, Clone, RuntimeDebug)]
  pub struct Market {
    /// Current market state
    pub state: MarketState,
  }

  /// The current state of a market.
  #[cfg_attr(feature = "std", derive(serde::Deserialize, serde::Serialize))]
  #[derive(Encode, Decode, Clone, RuntimeDebug, PartialEq)]
  pub enum MarketState {
    Active,
    Pending,
    Supervision,
  }

  #[derive(Encode, Decode, Clone, RuntimeDebug)]
  enum RequestType {
    Mint,
    Burn,
  }

  #[derive(Encode, Decode, Clone, PartialEq, RuntimeDebug)]
  enum RequestStatus {
    Pending,
    Cancelled,
    Approved,
    Rejected,
  }

  #[derive(Encode, Decode, Clone, RuntimeDebug)]
  pub struct Request<T: Config> {
    kind: RequestType,
    token: TokenId,
    requester: T::AccountId,
    amount: BalanceOf<T>,
    deposit_address: Vec<u8>,
    txid: Vec<u8>,
    timestamp: Timestamp,
    status: RequestStatus,
  }

  #[pallet::config]
  /// Configure the pallet by specifying the parameters and types on which it depends.
  pub trait Config: frame_system::Config + pallet_sudo::Config {
    type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
    type Assets: Transfer<Self::AccountId> + Inspect<Self::AccountId> + Mutate<Self::AccountId>;
    /// The loan's module id, keep all collaterals of CDPs.
    #[pallet::constant]
    type PalletId: Get<PalletId>;
    /// Weight information for extrinsics in this pallet.
    type WeightInfo: WeightInfo;
  }

  #[pallet::pallet]
  #[pallet::generate_store(pub (super) trait Store)]
  pub struct Pallet<T>(_);

  /// Quorum is enabled
  #[pallet::storage]
  #[pallet::getter(fn is_quorum_enabled)]
  pub(super) type QuorumStatus<T: Config> = StorageValue<_, bool, ValueQuery>;

  /// Requests
  #[pallet::storage]
  #[pallet::getter(fn locked_holders)]
  pub(super) type Requests<T: Config> =
    StorageMap<_, Blake2_128Concat, RequestId, Request<T>, OptionQuery>;

  /// Mapping of asset id to its market
  #[pallet::storage]
  pub type Markets<T: Config> = StorageMap<_, Blake2_128Concat, AssetIdOf<T>, Market>;

  /// Total number of collateral tokens in circulation
  // FIXME: Should be updated when a new MM (market maker) join this market.
  #[pallet::storage]
  #[pallet::getter(fn total_supply)]
  pub type TotalSupply<T: Config> =
    StorageMap<_, Blake2_128Concat, AssetIdOf<T>, BalanceOf<T>, ValueQuery>;

  /// Mapping of account addresses to deposit details
  /// Owner -> BalanceOf
  #[pallet::storage]
  #[pallet::getter(fn account_deposits)]
  pub type AccountDeposits<T: Config> = StorageDoubleMap<
    _,
    Blake2_128Concat,
    AssetIdOf<T>,
    Blake2_128Concat,
    T::AccountId,
    BalanceOf<T>,
    ValueQuery,
  >;

  #[pallet::genesis_config]
  pub struct GenesisConfig {
    pub quorum_enabled: bool,
    pub markets: Vec<(AssetId, Market)>,
  }

  #[cfg(feature = "std")]
  impl Default for GenesisConfig {
    fn default() -> Self {
      Self {
        quorum_enabled: true,
        markets: vec![],
      }
    }
  }

  #[pallet::genesis_build]
  impl<T: Config> GenesisBuild<T> for GenesisConfig {
    fn build(&self) {
      QuorumStatus::<T>::put(self.quorum_enabled);
    }
  }

  #[pallet::event]
  #[pallet::generate_deposit(pub (super) fn deposit_event)]
  pub enum Event<T: Config> {
    QuorumPaused,
    /// Event emitted when assets are deposited
    /// [sender, asset_id, amount]
    Deposited(T::AccountId, AssetIdOf<T>, BalanceOf<T>),
  }

  // Errors inform users that something went wrong.
  #[pallet::error]
  pub enum Error<T> {
    /// The Quorum is paused. Try again later.
    QuorumPaused,
    /// The quorum can't confirm the request because the ID do not exist.
    InvalidRequest,
    /// Market not activated
    MarketNotActivated,
  }

  // Dispatchable functions allows users to interact with the pallet and invoke state changes.
  // These functions materialize as "extrinsics", which are often compared to transactions.
  // Dispatchable functions must be annotated with a weight and must return a DispatchResult.
  #[pallet::call]
  impl<T: Config> Pallet<T>
  where
    BalanceOf<T>: FixedPointOperand,
    AssetIdOf<T>: AtLeast32BitUnsigned,
  {
    // Change quorum status
    #[pallet::weight(10000)]
    pub fn set_quorum_status(
      origin: OriginFor<T>,
      quorum_enabled: bool,
    ) -> DispatchResultWithPostInfo {
      // make sure it's the quprum
      ensure_root(origin)?;
      // update quorum
      QuorumStatus::<T>::put(quorum_enabled);
      // no payment required
      Ok(Pays::No.into())
    }

    /// Sender supplies assets into the market and receives internal supplies in exchange.
    ///
    /// - `asset_id`: the asset to be deposited.
    /// - `mint_amount`: the amount to be deposited.
    #[pallet::weight(T::WeightInfo::mint())]
    #[transactional]
    pub fn mint(
      origin: OriginFor<T>,
      asset_id: AssetIdOf<T>,
      mint_amount: BalanceOf<T>,
    ) -> DispatchResultWithPostInfo {
      let who = ensure_signed(origin)?;
      Self::ensure_not_paused()?;
      Self::ensure_currency(asset_id)?;

      // Transfer the asset fund to the Wrapr Account (using pallet_assets)
      T::Assets::transfer(asset_id, &who, &Self::account_id(), mint_amount, false)?;

      // Keep the deposit record for the account / asset id
      AccountDeposits::<T>::try_mutate(asset_id, &who, |deposits| -> DispatchResult {
        *deposits += mint_amount;
        Ok(())
      })?;

      // add the total supply
      TotalSupply::<T>::try_mutate(asset_id, |total_balance| -> DispatchResult {
        let new_balance = total_balance
          .checked_add(&mint_amount)
          .ok_or(ArithmeticError::Overflow)?;
        *total_balance = new_balance;
        Ok(())
      })?;

      // send event to the chain
      Self::deposit_event(Event::<T>::Deposited(who, asset_id, mint_amount));

      Ok(Pays::No.into())
    }

    // Confirm request (Quorum only)
    #[pallet::weight(10000)]
    pub fn confirm_request(
      origin: OriginFor<T>,
      request_id: RequestId,
    ) -> DispatchResultWithPostInfo {
      // make sure it's the quorum
      ensure_root(origin)?;
      // make sure it's not paused
      Self::ensure_not_paused()?;

      Requests::<T>::mutate(request_id, |request| match request {
        Some(request) => {
          // not pending?
          if request.status != RequestStatus::Pending {
            return Err(Error::<T>::InvalidRequest.into());
          }

          match request.kind {
            RequestType::Mint => {}
            RequestType::Burn => {}
          }

          // do not pay fees
          Ok(Pays::No.into())
        }
        // request not found
        None => Err(Error::<T>::InvalidRequest.into()),
      })
    }
  }

  // helper functions (not dispatchable)
  impl<T: Config> Pallet<T>
  where
    BalanceOf<T>: FixedPointOperand,
    AssetIdOf<T>: AtLeast32BitUnsigned,
  {
    pub fn account_id() -> T::AccountId {
      T::PalletId::get().into_account()
    }

    fn ensure_not_paused() -> Result<(), DispatchError> {
      if Self::is_quorum_enabled() {
        Ok(())
      } else {
        Err(Error::<T>::QuorumPaused.into())
      }
    }

    // Ensures a given `asset_id` exists on the `Assets` storage.
    fn ensure_currency(asset_id: AssetIdOf<T>) -> DispatchResult {
      if Self::active_markets().any(|(id, _)| id == asset_id) {
        Ok(())
      } else {
        Err(<Error<T>>::MarketNotActivated.into())
      }
    }

    // All markets that are `MarketStatus::Active`.
    fn active_markets() -> impl Iterator<Item = (AssetIdOf<T>, Market)> {
      Markets::<T>::iter().filter(|(_, market)| market.state == MarketState::Active)
    }
  }
}
