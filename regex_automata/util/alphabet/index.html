<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module provides APIs for dealing with the alphabets of finite state machines."><meta name="keywords" content="rust, rustlang, rust-lang, alphabet"><title>regex_automata::util::alphabet - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../regex_automata/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module alphabet</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">util</a>::<wbr><a class="mod" href="#">alphabet</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/util/alphabet.rs.html#1-1139">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module provides APIs for dealing with the alphabets of finite state
machines.</p>
<p>There are two principal types in this module, <a href="struct.ByteClasses.html" title="ByteClasses"><code>ByteClasses</code></a> and <a href="struct.Unit.html" title="Unit"><code>Unit</code></a>.
The former defines the alphabet of a finite state machine while the latter
represents an element of that alphabet.</p>
<p>To a first approximation, the alphabet of all automata in this crate is just
a <code>u8</code>. Namely, every distinct byte value. All 256 of them. In practice, this
can be quite wasteful when building a transition table for a DFA, since it
requires storing a state identifier for each element in the alphabet. Instead,
we collapse the alphabet of an automaton down into equivalence classes, where
every byte in the same equivalence class never discriminates between a match or
a non-match from any other byte in the same class. For example, in the regex
<code>[a-z]+</code>, then you could consider it having an alphabet consisting of two
equivalence classes: <code>a-z</code> and everything else. In terms of the transitions on
an automaton, it doesn’t actually require representing every distinct byte.
Just the equivalence classes.</p>
<p>The downside of equivalence classes is that, of course, searching a haystack
deals with individual byte values. Those byte values need to be mapped to
their corresponding equivalence class. This is what <code>ByteClasses</code> does. In
practice, doing this for every state transition has negligible impact on modern
CPUs. Moreover, it helps make more efficient use of the CPU cache by (possibly
considerably) shrinking the size of the transition table.</p>
<p>One last hiccup concerns <code>Unit</code>. Namely, because of look-around and how the
DFAs in this crate work, we need to add a sentinel value to our alphabet
of equivalence classes that represents the “end” of a search. We call that
sentinel <a href="struct.Unit.html#method.eoi" title="Unit::eoi"><code>Unit::eoi</code></a> or “end of input.” Thus, a <code>Unit</code> is either an
equivalence class corresponding to a set of bytes, or it is a special “end of
input” sentinel.</p>
<p>In general, you should not expect to need either of these types unless you’re
doing lower level shenanigans with DFAs, or even building your own DFAs.
(Although, you don’t have to use these types to build your own DFAs of course.)
For example, if you’re walking a DFA’s state graph, it’s probably useful to
make use of <a href="struct.ByteClasses.html" title="ByteClasses"><code>ByteClasses</code></a> to visit each element in the DFA’s alphabet instead
of just visiting every distinct <code>u8</code> value. The latter isn’t necessarily wrong,
but it could be potentially very wasteful.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ByteClassElements.html" title="regex_automata::util::alphabet::ByteClassElements struct">ByteClassElements</a></div><div class="item-right docblock-short">An iterator over all elements in an equivalence class.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ByteClassIter.html" title="regex_automata::util::alphabet::ByteClassIter struct">ByteClassIter</a></div><div class="item-right docblock-short">An iterator over each equivalence class.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ByteClassRepresentatives.html" title="regex_automata::util::alphabet::ByteClassRepresentatives struct">ByteClassRepresentatives</a></div><div class="item-right docblock-short">An iterator over representative bytes from each equivalence class.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ByteClasses.html" title="regex_automata::util::alphabet::ByteClasses struct">ByteClasses</a></div><div class="item-right docblock-short">A representation of byte oriented equivalence classes.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Unit.html" title="regex_automata::util::alphabet::Unit struct">Unit</a></div><div class="item-right docblock-short">Unit represents a single unit of haystack for DFA based regex engines.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>