<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Converts to and from various cases."><meta name="keywords" content="rust, rustlang, rust-lang, convert_case"><title>convert_case - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../convert_case/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../convert_case/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate convert_case</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.5.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">convert_case</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/convert_case/lib.rs.html#1-644">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Converts to and from various cases.</p>
<h2 id="command-line-utility-ccase"><a href="#command-line-utility-ccase">Command Line Utility <code>ccase</code></a></h2>
<p>This library was developed for the purposes of a command line utility for converting
the case of strings and filenames.  You can check out 
<a href="https://github.com/rutrum/convert-case/tree/master/ccase"><code>ccase</code> on Github</a>.</p>
<h2 id="rust-library"><a href="#rust-library">Rust Library</a></h2>
<p>Provides a <a href="enum.Case.html"><code>Case</code></a> enum which defines a variety of cases to convert into.
Strings have implemented the <a href="trait.Casing.html"><code>Casing</code></a> trait, which adds methods for 
case conversion.</p>
<p>You can convert strings into a case using the <a href="trait.Casing.html#tymethod.to_case"><code>to_case</code></a> method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="macro">assert_eq!</span>(<span class="string">&quot;Ronnie James Dio&quot;</span>, <span class="string">&quot;ronnie james dio&quot;</span>.to_case(Case::Title));
<span class="macro">assert_eq!</span>(<span class="string">&quot;ronnieJamesDio&quot;</span>, <span class="string">&quot;Ronnie_James_dio&quot;</span>.to_case(Case::Camel));
<span class="macro">assert_eq!</span>(<span class="string">&quot;Ronnie-James-Dio&quot;</span>, <span class="string">&quot;RONNIE_JAMES_DIO&quot;</span>.to_case(Case::Train));</code></pre></div>
<p>By default, <code>to_case</code> will split along a set of default word boundaries, that is</p>
<ul>
<li>space characters <code> </code>,</li>
<li>underscores <code>_</code>,</li>
<li>hyphens <code>-</code>,</li>
<li>changes in capitalization from lowercase to uppercase <code>aA</code>,</li>
<li>adjacent digits and letters <code>a1</code>, <code>1a</code>, <code>A1</code>, <code>1A</code>,</li>
<li>and acroynms <code>AAa</code> (as in <code>HTTPRequest</code>).</li>
</ul>
<p>For more accuracy, the <code>from_case</code> method splits based on the word boundaries
of a particular case.  For example, splitting from snake case will only use
underscores as word boundaries.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="macro">assert_eq!</span>(
    <span class="string">&quot;2020 04 16 My Cat Cali&quot;</span>,
    <span class="string">&quot;2020-04-16_my_cat_cali&quot;</span>.to_case(Case::Title)
);
<span class="macro">assert_eq!</span>(
    <span class="string">&quot;2020-04-16 My Cat Cali&quot;</span>,
    <span class="string">&quot;2020-04-16_my_cat_cali&quot;</span>.from_case(Case::Snake).to_case(Case::Title)
);</code></pre></div>
<p>Case conversion can detect acronyms for camel-like strings.  It also ignores any leading, 
trailing, or duplicate delimiters.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="macro">assert_eq!</span>(<span class="string">&quot;io_stream&quot;</span>, <span class="string">&quot;IOStream&quot;</span>.to_case(Case::Snake));
<span class="macro">assert_eq!</span>(<span class="string">&quot;my_json_parser&quot;</span>, <span class="string">&quot;myJSONParser&quot;</span>.to_case(Case::Snake));

<span class="macro">assert_eq!</span>(<span class="string">&quot;weird_var_name&quot;</span>, <span class="string">&quot;__weird--var _name-&quot;</span>.to_case(Case::Snake));</code></pre></div>
<p>It also works non-ascii characters.  However, no inferences on the language itself is made.
For instance, the digraph <code>ij</code> in Dutch will not be capitalized, because it is represented
as two distinct Unicode characters.  However, <code>æ</code> would be capitalized.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="macro">assert_eq!</span>(<span class="string">&quot;granat-äpfel&quot;</span>, <span class="string">&quot;GranatÄpfel&quot;</span>.to_case(Case::Kebab));

<span class="comment">// The example from str::to_lowercase documentation
</span><span class="kw">let </span>odysseus = <span class="string">&quot;ὈΔΥΣΣΕΎΣ&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;ὀδυσσεύς&quot;</span>, odysseus.to_case(Case::Lower));</code></pre></div>
<p>By default, characters followed by digits and vice-versa are
considered word boundaries.  In addition, any special ASCII characters (besides <code>_</code> and <code>-</code>)
are ignored.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="macro">assert_eq!</span>(<span class="string">&quot;e_5150&quot;</span>, <span class="string">&quot;E5150&quot;</span>.to_case(Case::Snake));
<span class="macro">assert_eq!</span>(<span class="string">&quot;10,000_days&quot;</span>, <span class="string">&quot;10,000Days&quot;</span>.to_case(Case::Snake));
<span class="macro">assert_eq!</span>(<span class="string">&quot;HELLO, WORLD!&quot;</span>, <span class="string">&quot;Hello, world!&quot;</span>.to_case(Case::Upper));
<span class="macro">assert_eq!</span>(<span class="string">&quot;One\ntwo\nthree&quot;</span>, <span class="string">&quot;ONE\nTWO\nTHREE&quot;</span>.to_case(Case::Title));</code></pre></div>
<p>You can also test what case a string is in.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="macro">assert!</span>( <span class="string">&quot;css-class-name&quot;</span>.is_case(Case::Kebab));
<span class="macro">assert!</span>(!<span class="string">&quot;css-class-name&quot;</span>.is_case(Case::Snake));
<span class="macro">assert!</span>(!<span class="string">&quot;UPPER_CASE_VAR&quot;</span>.is_case(Case::Snake));</code></pre></div>
<h2 id="note-on-accuracy"><a href="#note-on-accuracy">Note on Accuracy</a></h2>
<p>The <code>Casing</code> methods <code>from_case</code> and <code>to_case</code> do not fail.  Conversion to a case will always
succeed.  However, the results can still be unexpected.  Failure to detect any word boundaries
for a particular case means the entire string will be considered a single word.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing};

<span class="comment">// Mistakenly parsing using Case::Snake
</span><span class="macro">assert_eq!</span>(<span class="string">&quot;My-kebab-var&quot;</span>, <span class="string">&quot;my-kebab-var&quot;</span>.from_case(Case::Snake).to_case(Case::Title));

<span class="comment">// Converts using an unexpected method
</span><span class="macro">assert_eq!</span>(<span class="string">&quot;my_kebab_like_variable&quot;</span>, <span class="string">&quot;myKebab-like-variable&quot;</span>.to_case(Case::Snake));</code></pre></div>
<h2 id="boundary-specificity"><a href="#boundary-specificity">Boundary Specificity</a></h2>
<p>It can be difficult to determine how to split a string into words.  That is why this case
provides the <a href="trait.Casing.html#tymethod.from_case"><code>from_case</code></a> functionality, but sometimes that isn’t enough
to meet a specific use case.</p>
<p>Take an identifier has the word <code>2D</code>, such as <code>scale2D</code>.  No exclusive usage of <code>from_case</code> will
be enough to solve the problem.  In this case we can further specify which boundaries to split
the string on.  <code>convert_case</code> provides some patterns for achieving this specificity.
We can specify what boundaries we want to split on using the <a href="enum.Boundary.html"><code>Boundary</code> enum</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Boundary, Case, Casing};

<span class="comment">// Not quite what we want
</span><span class="macro">assert_eq!</span>(
    <span class="string">&quot;scale_2_d&quot;</span>,
    <span class="string">&quot;scale2D&quot;
        </span>.from_case(Case::Camel)
        .to_case(Case::Snake)
);

<span class="comment">// Remove boundary from Case::Camel
</span><span class="macro">assert_eq!</span>(
    <span class="string">&quot;scale_2d&quot;</span>,
    <span class="string">&quot;scale2D&quot;
        </span>.from_case(Case::Camel)
        .without_boundaries(<span class="kw-2">&amp;</span>[Boundary::DigitUpper, Boundary::DigitLower])
        .to_case(Case::Snake)
);

<span class="comment">// Write boundaries explicitly
</span><span class="macro">assert_eq!</span>(
    <span class="string">&quot;scale_2d&quot;</span>,
    <span class="string">&quot;scale2D&quot;
        </span>.with_boundaries(<span class="kw-2">&amp;</span>[Boundary::LowerDigit])
        .to_case(Case::Snake)
);</code></pre></div>
<p>The <code>Casing</code> trait provides initial methods, but any subsequent methods that do not resolve
the conversion return a <a href="struct.StateConverter.html" title="StateConverter"><code>StateConverter</code></a> struct.  It contains similar methods as <code>Casing</code>.</p>
<h2 id="custom-cases"><a href="#custom-cases">Custom Cases</a></h2>
<p>Because <code>Case</code> is an enum, you can’t create your own variant for your use case.  However
the parameters for case conversion have been encapsulated into the <a href="struct.Converter.html" title="Converter"><code>Converter</code></a> struct
which can be used for specific use cases.</p>
<p>Suppose you wanted to format a word like camel case, where the first word is lower case and the
rest are capitalized.  But you want to include a delimeter like underscore.  This case isn’t
available as a <code>Case</code> variant, but you can create it by constructing the parameters of the
<code>Converter</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>convert_case::{Case, Casing, Converter, Pattern};

<span class="kw">let </span>conv = Converter::new()
    .set_pattern(Pattern::Camel)
    .set_delim(<span class="string">&quot;_&quot;</span>);

<span class="macro">assert_eq!</span>(
    <span class="string">&quot;my_Special_Case&quot;</span>,
    conv.convert(<span class="string">&quot;My Special Case&quot;</span>)
)</code></pre></div>
<p>Just as with the <code>Casing</code> trait, you can also manually set the boundaries strings are split 
on.  You can use any of the <a href="enum.Pattern.html" title="Pattern"><code>Pattern</code></a> variants available.  This even includes <a href="enum.Pattern.html#variant.Sentence" title="Pattern::Sentence"><code>Pattern::Sentence</code></a>
which isn’t used in any <code>Case</code> variant.  You can also set no pattern at all, which will
maintain the casing of each letter in the input string.  You can also, of course, set any string as your
delimeter.</p>
<p>For more details on how strings are converted, see the docs for <a href="struct.Converter.html" title="Converter"><code>Converter</code></a>.</p>
<h2 id="random-feature"><a href="#random-feature">Random Feature</a></h2>
<p>To ensure this library had zero dependencies, randomness was moved to the <em>random</em> feature,
which requires the <code>rand</code> crate. You can enable this feature by including the
following in your <code>Cargo.toml</code>.</p>
<div class="example-wrap"><pre class="language-{toml}"><code>[dependencies]
convert_case = { version = &quot;^0.3.0&quot;, features = [&quot;random&quot;] }
</code></pre></div>
<p>This will add two additional cases: Random and PseudoRandom.  You can read about their
construction in the <a href="enum.Case.html">Case enum</a>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Converter.html" title="convert_case::Converter struct">Converter</a></div><div class="item-right docblock-short">The parameters for performing a case conversion.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StateConverter.html" title="convert_case::StateConverter struct">StateConverter</a></div><div class="item-right docblock-short">Holds information about parsing before converting into a case.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Boundary.html" title="convert_case::Boundary enum">Boundary</a></div><div class="item-right docblock-short">A boundary defines how a string is split into words.  Some boundaries, <code>Hyphen</code>, <code>Underscore</code>,
and <code>Space</code>, consume the character they split on, whereas the other boundaries
do not.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Case.html" title="convert_case::Case enum">Case</a></div><div class="item-right docblock-short">Defines the type of casing a string can be.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Pattern.html" title="convert_case::Pattern enum">Pattern</a></div><div class="item-right docblock-short">A pattern is how a set of words is mutated before joining with
a delimeter.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Casing.html" title="convert_case::Casing trait">Casing</a></div><div class="item-right docblock-short">Describes items that can be converted into a case.  This trait is used
in conjunction with the <a href="struct.StateConverter.html" title="StateConverter"><code>StateConverter</code></a> struct which is returned from a couple
methods on <code>Casing</code>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="convert_case" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>