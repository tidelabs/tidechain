<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/usr/local/cargo/registry/src/github.com-1ecc6299db9ec823/snap-1.0.5/src/write.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>write.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../snap/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
This module provides a `std::io::Write` implementation:

- `write::FrameEncoder` wraps another `std::io::Write` implemenation, and
  compresses data encoded using the Snappy frame format. Use this if you have
  uncompressed data source and wish to write it as compressed data.

It would also be possible to provide a `write::FrameDecoder`, which decompresses
data as it writes it, but it hasn&#39;t been implemented yet.
*/

</span><span class="kw">use </span>std::fmt;
<span class="kw">use </span>std::io::{<span class="self">self</span>, Write};

<span class="kw">use </span><span class="kw">crate</span>::compress::Encoder;
<span class="kw">use </span><span class="kw">crate</span>::crc32::CheckSummer;
<span class="kw">pub use </span><span class="kw">crate</span>::error::IntoInnerError;
<span class="kw">use </span><span class="kw">crate</span>::frame::{
    compress_frame, CHUNK_HEADER_AND_CRC_SIZE, MAX_COMPRESS_BLOCK_SIZE,
    STREAM_IDENTIFIER,
};
<span class="kw">use </span><span class="kw">crate</span>::MAX_BLOCK_SIZE;

<span class="doccomment">/// A writer for compressing a Snappy stream.
///
/// This `FrameEncoder` wraps any other writer that implements `io::Write`.
/// Bytes written to this writer are compressed using the [Snappy frame
/// format](https://github.com/google/snappy/blob/master/framing_format.txt)
/// (file extension `sz`, MIME type `application/x-snappy-framed`).
///
/// Writes are buffered automatically, so there&#39;s no need to wrap the given
/// writer in a `std::io::BufWriter`.
///
/// The writer will be flushed automatically when it is dropped. If an error
/// occurs, it is ignored.
</span><span class="kw">pub struct </span>FrameEncoder&lt;W: io::Write&gt; {
    <span class="doccomment">/// Our main internal state, split out for borrowck reasons (happily paid).
    ///
    /// Also, it&#39;s an `Option` so we can move out of it even though
    /// `FrameEncoder` impls `Drop`.
    </span>inner: <span class="prelude-ty">Option</span>&lt;Inner&lt;W&gt;&gt;,
    <span class="doccomment">/// Our buffer of uncompressed bytes. This isn&#39;t part of `inner` because
    /// we may write bytes directly from the caller if the given buffer was
    /// big enough. As a result, the main `write` implementation needs to
    /// accept either the internal buffer or the caller&#39;s bytes directly. Since
    /// `write` requires a mutable borrow, we satisfy the borrow checker by
    /// separating `src` from the rest of the state.
    </span>src: Vec&lt;u8&gt;,
}

<span class="kw">struct </span>Inner&lt;W&gt; {
    <span class="doccomment">/// The underlying writer.
    </span>w: W,
    <span class="doccomment">/// An encoder that we reuse that does the actual block based compression.
    </span>enc: Encoder,
    <span class="doccomment">/// A CRC32 checksummer that is configured to either use the portable
    /// fallback version or the SSE4.2 accelerated version when the right CPU
    /// features are available.
    </span>checksummer: CheckSummer,
    <span class="doccomment">/// The compressed bytes buffer. Bytes are compressed from src (usually)
    /// to dst before being written to w.
    </span>dst: Vec&lt;u8&gt;,
    <span class="doccomment">/// When false, the stream identifier (with magic bytes) must precede the
    /// next write.
    </span>wrote_stream_ident: bool,
    <span class="doccomment">/// Space for writing the header of a chunk before writing it to the
    /// underlying writer.
    </span>chunk_header: [u8; <span class="number">8</span>],
}

<span class="kw">impl</span>&lt;W: io::Write&gt; FrameEncoder&lt;W&gt; {
    <span class="doccomment">/// Create a new writer for streaming Snappy compression.
    </span><span class="kw">pub fn </span>new(wtr: W) -&gt; FrameEncoder&lt;W&gt; {
        FrameEncoder {
            inner: <span class="prelude-val">Some</span>(Inner {
                w: wtr,
                enc: Encoder::new(),
                checksummer: CheckSummer::new(),
                dst: <span class="macro">vec!</span>[<span class="number">0</span>; MAX_COMPRESS_BLOCK_SIZE],
                wrote_stream_ident: <span class="bool-val">false</span>,
                chunk_header: [<span class="number">0</span>; CHUNK_HEADER_AND_CRC_SIZE],
            }),
            src: Vec::with_capacity(MAX_BLOCK_SIZE),
        }
    }

    <span class="doccomment">/// Returns the underlying stream, consuming and flushing this writer.
    ///
    /// If flushing the writer caused an error, then an `IntoInnerError` is
    /// returned, which contains both the writer and the original writer.
    </span><span class="kw">pub fn </span>into_inner(<span class="kw-2">mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;W, IntoInnerError&lt;FrameEncoder&lt;W&gt;&gt;&gt; {
        <span class="kw">match </span><span class="self">self</span>.flush() {
            <span class="prelude-val">Ok</span>(()) =&gt; <span class="prelude-val">Ok</span>(<span class="self">self</span>.inner.take().unwrap().w),
            <span class="prelude-val">Err</span>(err) =&gt; <span class="prelude-val">Err</span>(IntoInnerError::new(<span class="self">self</span>, err)),
        }
    }

    <span class="doccomment">/// Gets a reference to the underlying writer in this encoder.
    </span><span class="kw">pub fn </span>get_ref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>W {
        <span class="kw-2">&amp;</span><span class="self">self</span>.inner.as_ref().unwrap().w
    }

    <span class="doccomment">/// Gets a reference to the underlying writer in this encoder.
    ///
    /// Note that mutating the output/input state of the stream may corrupt
    /// this encoder, so care must be taken when using this method.
    </span><span class="kw">pub fn </span>get_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;mut </span>W {
        <span class="kw-2">&amp;mut </span><span class="self">self</span>.inner.as_mut().unwrap().w
    }
}

<span class="kw">impl</span>&lt;W: io::Write&gt; Drop <span class="kw">for </span>FrameEncoder&lt;W&gt; {
    <span class="kw">fn </span>drop(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="kw">if </span><span class="self">self</span>.inner.is_some() {
            <span class="comment">// Ignore errors because we can&#39;t conceivably return an error and
            // panicing in a dtor is bad juju.
            </span><span class="kw">let _ </span>= <span class="self">self</span>.flush();
        }
    }
}

<span class="kw">impl</span>&lt;W: io::Write&gt; io::Write <span class="kw">for </span>FrameEncoder&lt;W&gt; {
    <span class="kw">fn </span>write(<span class="kw-2">&amp;mut </span><span class="self">self</span>, <span class="kw-2">mut </span>buf: <span class="kw-2">&amp;</span>[u8]) -&gt; io::Result&lt;usize&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>total = <span class="number">0</span>;
        <span class="comment">// If there isn&#39;t enough room to add buf to src, then add only a piece
        // of it, flush it and mush on.
        </span><span class="kw">loop </span>{
            <span class="kw">let </span>free = <span class="self">self</span>.src.capacity() - <span class="self">self</span>.src.len();
            <span class="comment">// n is the number of bytes extracted from buf.
            </span><span class="kw">let </span>n = <span class="kw">if </span>buf.len() &lt;= free {
                <span class="kw">break</span>;
            } <span class="kw">else if </span><span class="self">self</span>.src.is_empty() {
                <span class="comment">// If buf is bigger than our entire buffer then avoid
                // the indirection and write the buffer directly.
                </span><span class="self">self</span>.inner.as_mut().unwrap().write(buf)<span class="question-mark">?
            </span>} <span class="kw">else </span>{
                <span class="self">self</span>.src.extend_from_slice(<span class="kw-2">&amp;</span>buf[<span class="number">0</span>..free]);
                <span class="self">self</span>.flush()<span class="question-mark">?</span>;
                free
            };
            buf = <span class="kw-2">&amp;</span>buf[n..];
            total += n;
        }
        <span class="comment">// We&#39;re only here if buf.len() will fit within the available space of
        // self.src.
        </span><span class="macro">debug_assert!</span>(buf.len() &lt;= (<span class="self">self</span>.src.capacity() - <span class="self">self</span>.src.len()));
        <span class="self">self</span>.src.extend_from_slice(buf);
        total += buf.len();
        <span class="comment">// We should never expand or contract self.src.
        </span><span class="macro">debug_assert!</span>(<span class="self">self</span>.src.capacity() == MAX_BLOCK_SIZE);
        <span class="prelude-val">Ok</span>(total)
    }

    <span class="kw">fn </span>flush(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; io::Result&lt;()&gt; {
        <span class="kw">if </span><span class="self">self</span>.src.is_empty() {
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }
        <span class="self">self</span>.inner.as_mut().unwrap().write(<span class="kw-2">&amp;</span><span class="self">self</span>.src)<span class="question-mark">?</span>;
        <span class="self">self</span>.src.truncate(<span class="number">0</span>);
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">impl</span>&lt;W: io::Write&gt; Inner&lt;W&gt; {
    <span class="kw">fn </span>write(<span class="kw-2">&amp;mut </span><span class="self">self</span>, <span class="kw-2">mut </span>buf: <span class="kw-2">&amp;</span>[u8]) -&gt; io::Result&lt;usize&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>total = <span class="number">0</span>;
        <span class="kw">if </span>!<span class="self">self</span>.wrote_stream_ident {
            <span class="self">self</span>.wrote_stream_ident = <span class="bool-val">true</span>;
            <span class="self">self</span>.w.write_all(STREAM_IDENTIFIER)<span class="question-mark">?</span>;
        }
        <span class="kw">while </span>!buf.is_empty() {
            <span class="comment">// Advance buf and get our block.
            </span><span class="kw">let </span><span class="kw-2">mut </span>src = buf;
            <span class="kw">if </span>src.len() &gt; MAX_BLOCK_SIZE {
                src = <span class="kw-2">&amp;</span>src[<span class="number">0</span>..MAX_BLOCK_SIZE];
            }
            buf = <span class="kw-2">&amp;</span>buf[src.len()..];

            <span class="kw">let </span>frame_data = compress_frame(
                <span class="kw-2">&amp;mut </span><span class="self">self</span>.enc,
                <span class="self">self</span>.checksummer,
                src,
                <span class="kw-2">&amp;mut </span><span class="self">self</span>.chunk_header,
                <span class="kw-2">&amp;mut </span><span class="self">self</span>.dst,
                <span class="bool-val">false</span>,
            )<span class="question-mark">?</span>;
            <span class="self">self</span>.w.write_all(<span class="kw-2">&amp;</span><span class="self">self</span>.chunk_header)<span class="question-mark">?</span>;
            <span class="self">self</span>.w.write_all(frame_data)<span class="question-mark">?</span>;
            total += src.len();
        }
        <span class="prelude-val">Ok</span>(total)
    }
}

<span class="kw">impl</span>&lt;W: fmt::Debug + io::Write&gt; fmt::Debug <span class="kw">for </span>FrameEncoder&lt;W&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter) -&gt; fmt::Result {
        f.debug_struct(<span class="string">&quot;FrameEncoder&quot;</span>)
            .field(<span class="string">&quot;inner&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.inner)
            .field(<span class="string">&quot;src&quot;</span>, <span class="kw-2">&amp;</span><span class="string">&quot;[...]&quot;</span>)
            .finish()
    }
}

<span class="kw">impl</span>&lt;W: fmt::Debug + io::Write&gt; fmt::Debug <span class="kw">for </span>Inner&lt;W&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter) -&gt; fmt::Result {
        f.debug_struct(<span class="string">&quot;Inner&quot;</span>)
            .field(<span class="string">&quot;w&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.w)
            .field(<span class="string">&quot;enc&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.enc)
            .field(<span class="string">&quot;checksummer&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.checksummer)
            .field(<span class="string">&quot;dst&quot;</span>, <span class="kw-2">&amp;</span><span class="string">&quot;[...]&quot;</span>)
            .field(<span class="string">&quot;wrote_stream_ident&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.wrote_stream_ident)
            .field(<span class="string">&quot;chunk_header&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.chunk_header)
            .finish()
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="snap" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>