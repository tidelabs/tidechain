<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/usr/local/cargo/git/checkouts/substrate-773f176d546a32fa/12b0503/primitives/state-machine/src/overlayed_changes/changeset.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>changeset.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../../sp_state_machine/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
</pre><pre class="rust"><code><span class="comment">// This file is part of Substrate.

// Copyright (C) 2020-2022 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License

</span><span class="doccomment">//! Houses the code that implements the transactional overlay storage.

</span><span class="kw">use super</span>::{Extrinsics, StorageKey, StorageValue};

<span class="attribute">#[cfg(not(feature = <span class="string">&quot;std&quot;</span>))]
</span><span class="kw">use </span>sp_std::collections::btree_set::BTreeSet <span class="kw">as </span>Set;
<span class="attribute">#[cfg(feature = <span class="string">&quot;std&quot;</span>)]
</span><span class="kw">use </span>std::collections::HashSet <span class="kw">as </span>Set;

<span class="kw">use </span><span class="kw">crate</span>::warn;
<span class="kw">use </span>smallvec::SmallVec;
<span class="kw">use </span>sp_std::{
	collections::{btree_map::BTreeMap, btree_set::BTreeSet},
	hash::Hash,
};

<span class="kw">const </span>PROOF_OVERLAY_NON_EMPTY: <span class="kw-2">&amp;</span>str = <span class="string">&quot;\
	An OverlayValue is always created with at least one transaction and dropped as soon
	as the last transaction is removed; qed&quot;</span>;

<span class="kw">type </span>DirtyKeysSets&lt;K&gt; = SmallVec&lt;[Set&lt;K&gt;; <span class="number">5</span>]&gt;;
<span class="kw">type </span>Transactions&lt;V&gt; = SmallVec&lt;[InnerValue&lt;V&gt;; <span class="number">5</span>]&gt;;

<span class="doccomment">/// Error returned when trying to commit or rollback while no transaction is open or
/// when the runtime is trying to close a transaction started by the client.
</span><span class="attribute">#[derive(Debug)]
#[cfg_attr(test, derive(PartialEq))]
</span><span class="kw">pub struct </span>NoOpenTransaction;

<span class="doccomment">/// Error when calling `enter_runtime` when already being in runtime execution mode.
</span><span class="attribute">#[derive(Debug)]
#[cfg_attr(test, derive(PartialEq))]
</span><span class="kw">pub struct </span>AlreadyInRuntime;

<span class="doccomment">/// Error when calling `exit_runtime` when not being in runtime exection mdde.
</span><span class="attribute">#[derive(Debug)]
#[cfg_attr(test, derive(PartialEq))]
</span><span class="kw">pub struct </span>NotInRuntime;

<span class="doccomment">/// Describes in which mode the node is currently executing.
</span><span class="attribute">#[derive(Debug, Clone, Copy)]
</span><span class="kw">pub enum </span>ExecutionMode {
	<span class="doccomment">/// Exeuting in client mode: Removal of all transactions possible.
	</span>Client,
	<span class="doccomment">/// Executing in runtime mode: Transactions started by the client are protected.
	</span>Runtime,
}

<span class="attribute">#[derive(Debug, Default, Clone)]
#[cfg_attr(test, derive(PartialEq))]
</span><span class="kw">struct </span>InnerValue&lt;V&gt; {
	<span class="doccomment">/// Current value. None if value has been deleted.
	</span>value: V,
	<span class="doccomment">/// The set of extrinsic indices where the values has been changed.
	</span>extrinsics: Extrinsics,
}

<span class="doccomment">/// An overlay that contains all versions of a value for a specific key.
</span><span class="attribute">#[derive(Debug, Clone)]
#[cfg_attr(test, derive(PartialEq))]
</span><span class="kw">pub struct </span>OverlayedEntry&lt;V&gt; {
	<span class="doccomment">/// The individual versions of that value.
	/// One entry per transactions during that the value was actually written.
	</span>transactions: Transactions&lt;V&gt;,
}

<span class="kw">impl</span>&lt;V&gt; Default <span class="kw">for </span>OverlayedEntry&lt;V&gt; {
	<span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
		<span class="self">Self </span>{ transactions: SmallVec::new() }
	}
}

<span class="doccomment">/// History of value, with removal support.
</span><span class="kw">pub type </span>OverlayedValue = OverlayedEntry&lt;<span class="prelude-ty">Option</span>&lt;StorageValue&gt;&gt;;

<span class="doccomment">/// Change set for basic key value with extrinsics index recording and removal support.
</span><span class="kw">pub type </span>OverlayedChangeSet = OverlayedMap&lt;StorageKey, <span class="prelude-ty">Option</span>&lt;StorageValue&gt;&gt;;

<span class="doccomment">/// Holds a set of changes with the ability modify them using nested transactions.
</span><span class="attribute">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>OverlayedMap&lt;K: Ord + Hash, V&gt; {
	<span class="doccomment">/// Stores the changes that this overlay constitutes.
	</span>changes: BTreeMap&lt;K, OverlayedEntry&lt;V&gt;&gt;,
	<span class="doccomment">/// Stores which keys are dirty per transaction. Needed in order to determine which
	/// values to merge into the parent transaction on commit. The length of this vector
	/// therefore determines how many nested transactions are currently open (depth).
	</span>dirty_keys: DirtyKeysSets&lt;K&gt;,
	<span class="doccomment">/// The number of how many transactions beginning from the first transactions are started
	/// by the client. Those transactions are protected against close (commit, rollback)
	/// when in runtime mode.
	</span>num_client_transactions: usize,
	<span class="doccomment">/// Determines whether the node is using the overlay from the client or the runtime.
	</span>execution_mode: ExecutionMode,
}

<span class="kw">impl</span>&lt;K: Ord + Hash, V&gt; Default <span class="kw">for </span>OverlayedMap&lt;K, V&gt; {
	<span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
		<span class="self">Self </span>{
			changes: BTreeMap::new(),
			dirty_keys: SmallVec::new(),
			num_client_transactions: Default::default(),
			execution_mode: Default::default(),
		}
	}
}

<span class="kw">impl </span>Default <span class="kw">for </span>ExecutionMode {
	<span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
		<span class="self">Self</span>::Client
	}
}

<span class="kw">impl</span>&lt;V&gt; OverlayedEntry&lt;V&gt; {
	<span class="doccomment">/// The value as seen by the current transaction.
	</span><span class="kw">pub fn </span>value_ref(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>V {
		<span class="kw-2">&amp;</span><span class="self">self</span>.transactions.last().expect(PROOF_OVERLAY_NON_EMPTY).value
	}

	<span class="doccomment">/// The value as seen by the current transaction.
	</span><span class="kw">pub fn </span>into_value(<span class="kw-2">mut </span><span class="self">self</span>) -&gt; V {
		<span class="self">self</span>.transactions.pop().expect(PROOF_OVERLAY_NON_EMPTY).value
	}

	<span class="doccomment">/// Unique list of extrinsic indices which modified the value.
	</span><span class="kw">pub fn </span>extrinsics(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; BTreeSet&lt;u32&gt; {
		<span class="kw">let </span><span class="kw-2">mut </span>set = BTreeSet::new();
		<span class="self">self</span>.transactions
			.iter()
			.for_each(|t| t.extrinsics.copy_extrinsics_into(<span class="kw-2">&amp;mut </span>set));
		set
	}

	<span class="doccomment">/// Mutable reference to the most recent version.
	</span><span class="kw">fn </span>value_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;mut </span>V {
		<span class="kw-2">&amp;mut </span><span class="self">self</span>.transactions.last_mut().expect(PROOF_OVERLAY_NON_EMPTY).value
	}

	<span class="doccomment">/// Remove the last version and return it.
	</span><span class="kw">fn </span>pop_transaction(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; InnerValue&lt;V&gt; {
		<span class="self">self</span>.transactions.pop().expect(PROOF_OVERLAY_NON_EMPTY)
	}

	<span class="doccomment">/// Mutable reference to the set which holds the indices for the **current transaction only**.
	</span><span class="kw">fn </span>transaction_extrinsics_mut(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;mut </span>Extrinsics {
		<span class="kw-2">&amp;mut </span><span class="self">self</span>.transactions.last_mut().expect(PROOF_OVERLAY_NON_EMPTY).extrinsics
	}

	<span class="doccomment">/// Writes a new version of a value.
	///
	/// This makes sure that the old version is not overwritten and can be properly
	/// rolled back when required.
	</span><span class="kw">fn </span>set(<span class="kw-2">&amp;mut </span><span class="self">self</span>, value: V, first_write_in_tx: bool, at_extrinsic: <span class="prelude-ty">Option</span>&lt;u32&gt;) {
		<span class="kw">if </span>first_write_in_tx || <span class="self">self</span>.transactions.is_empty() {
			<span class="self">self</span>.transactions.push(InnerValue { value, extrinsics: Default::default() });
		} <span class="kw">else </span>{
			<span class="kw-2">*</span><span class="self">self</span>.value_mut() = value;
		}

		<span class="kw">if let </span><span class="prelude-val">Some</span>(extrinsic) = at_extrinsic {
			<span class="self">self</span>.transaction_extrinsics_mut().insert(extrinsic);
		}
	}
}

<span class="kw">impl </span>OverlayedEntry&lt;<span class="prelude-ty">Option</span>&lt;StorageValue&gt;&gt; {
	<span class="doccomment">/// The value as seen by the current transaction.
	</span><span class="kw">pub fn </span>value(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>StorageValue&gt; {
		<span class="self">self</span>.value_ref().as_ref()
	}
}

<span class="doccomment">/// Inserts a key into the dirty set.
///
/// Returns true iff we are currently have at least one open transaction and if this
/// is the first write to the given key that transaction.
</span><span class="kw">fn </span>insert_dirty&lt;K: Ord + Hash&gt;(set: <span class="kw-2">&amp;mut </span>DirtyKeysSets&lt;K&gt;, key: K) -&gt; bool {
	set.last_mut().map(|dk| dk.insert(key)).unwrap_or_default()
}

<span class="kw">impl</span>&lt;K: Ord + Hash + Clone, V&gt; OverlayedMap&lt;K, V&gt; {
	<span class="doccomment">/// Create a new changeset at the same transaction state but without any contents.
	///
	/// This changeset might be created when there are already open transactions.
	/// We need to catch up here so that the child is at the same transaction depth.
	</span><span class="kw">pub fn </span>spawn_child(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self </span>{
		<span class="kw">use </span>sp_std::iter::repeat;
		<span class="self">Self </span>{
			changes: Default::default(),
			dirty_keys: repeat(Set::new()).take(<span class="self">self</span>.transaction_depth()).collect(),
			num_client_transactions: <span class="self">self</span>.num_client_transactions,
			execution_mode: <span class="self">self</span>.execution_mode,
		}
	}

	<span class="doccomment">/// True if no changes at all are contained in the change set.
	</span><span class="kw">pub fn </span>is_empty(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
		<span class="self">self</span>.changes.is_empty()
	}

	<span class="doccomment">/// Get an optional reference to the value stored for the specified key.
	</span><span class="kw">pub fn </span>get&lt;Q&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, key: <span class="kw-2">&amp;</span>Q) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>OverlayedEntry&lt;V&gt;&gt;
	<span class="kw">where
		</span>K: sp_std::borrow::Borrow&lt;Q&gt;,
		Q: Ord + <span class="question-mark">?</span>Sized,
	{
		<span class="self">self</span>.changes.get(key)
	}

	<span class="doccomment">/// Set a new value for the specified key.
	///
	/// Can be rolled back or committed when called inside a transaction.
	</span><span class="kw">pub fn </span>set(<span class="kw-2">&amp;mut </span><span class="self">self</span>, key: K, value: V, at_extrinsic: <span class="prelude-ty">Option</span>&lt;u32&gt;) {
		<span class="kw">let </span>overlayed = <span class="self">self</span>.changes.entry(key.clone()).or_default();
		overlayed.set(value, insert_dirty(<span class="kw-2">&amp;mut </span><span class="self">self</span>.dirty_keys, key), at_extrinsic);
	}

	<span class="doccomment">/// Get a list of all changes as seen by current transaction.
	</span><span class="kw">pub fn </span>changes(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw">impl </span>Iterator&lt;Item = (<span class="kw-2">&amp;</span>K, <span class="kw-2">&amp;</span>OverlayedEntry&lt;V&gt;)&gt; {
		<span class="self">self</span>.changes.iter()
	}

	<span class="doccomment">/// Get a list of all changes as seen by current transaction, consumes
	/// the overlay.
	</span><span class="kw">pub fn </span>into_changes(<span class="self">self</span>) -&gt; <span class="kw">impl </span>Iterator&lt;Item = (K, OverlayedEntry&lt;V&gt;)&gt; {
		<span class="self">self</span>.changes.into_iter()
	}

	<span class="doccomment">/// Consume this changeset and return all committed changes.
	///
	/// Panics:
	/// Panics if there are open transactions: `transaction_depth() &gt; 0`
	</span><span class="kw">pub fn </span>drain_commited(<span class="self">self</span>) -&gt; <span class="kw">impl </span>Iterator&lt;Item = (K, V)&gt; {
		<span class="macro">assert!</span>(<span class="self">self</span>.transaction_depth() == <span class="number">0</span>, <span class="string">&quot;Drain is not allowed with open transactions.&quot;</span>);
		<span class="self">self</span>.changes.into_iter().map(|(k, <span class="kw-2">mut </span>v)| (k, v.pop_transaction().value))
	}

	<span class="doccomment">/// Returns the current nesting depth of the transaction stack.
	///
	/// A value of zero means that no transaction is open and changes are committed on write.
	</span><span class="kw">pub fn </span>transaction_depth(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
		<span class="self">self</span>.dirty_keys.len()
	}

	<span class="doccomment">/// Call this before transfering control to the runtime.
	///
	/// This protects all existing transactions from being removed by the runtime.
	/// Calling this while already inside the runtime will return an error.
	</span><span class="kw">pub fn </span>enter_runtime(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), AlreadyInRuntime&gt; {
		<span class="kw">if let </span>ExecutionMode::Runtime = <span class="self">self</span>.execution_mode {
			<span class="kw">return </span><span class="prelude-val">Err</span>(AlreadyInRuntime)
		}
		<span class="self">self</span>.execution_mode = ExecutionMode::Runtime;
		<span class="self">self</span>.num_client_transactions = <span class="self">self</span>.transaction_depth();
		<span class="prelude-val">Ok</span>(())
	}

	<span class="doccomment">/// Call this when control returns from the runtime.
	///
	/// This commits all dangling transaction left open by the runtime.
	/// Calling this while already outside the runtime will return an error.
	</span><span class="kw">pub fn </span>exit_runtime(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), NotInRuntime&gt; {
		<span class="kw">if let </span>ExecutionMode::Client = <span class="self">self</span>.execution_mode {
			<span class="kw">return </span><span class="prelude-val">Err</span>(NotInRuntime)
		}
		<span class="self">self</span>.execution_mode = ExecutionMode::Client;
		<span class="kw">if </span><span class="self">self</span>.has_open_runtime_transactions() {
			<span class="macro">warn!</span>(
				<span class="string">&quot;{} storage transactions are left open by the runtime. Those will be rolled back.&quot;</span>,
				<span class="self">self</span>.transaction_depth() - <span class="self">self</span>.num_client_transactions,
			);
		}
		<span class="kw">while </span><span class="self">self</span>.has_open_runtime_transactions() {
			<span class="self">self</span>.rollback_transaction()
				.expect(<span class="string">&quot;The loop condition checks that the transaction depth is &gt; 0; qed&quot;</span>);
		}
		<span class="prelude-val">Ok</span>(())
	}

	<span class="doccomment">/// Start a new nested transaction.
	///
	/// This allows to either commit or roll back all changes that were made while this
	/// transaction was open. Any transaction must be closed by either `commit_transaction`
	/// or `rollback_transaction` before this overlay can be converted into storage changes.
	///
	/// Changes made without any open transaction are committed immediately.
	</span><span class="kw">pub fn </span>start_transaction(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
		<span class="self">self</span>.dirty_keys.push(Default::default());
	}

	<span class="doccomment">/// Rollback the last transaction started by `start_transaction`.
	///
	/// Any changes made during that transaction are discarded. Returns an error if
	/// there is no open transaction that can be rolled back.
	</span><span class="kw">pub fn </span>rollback_transaction(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), NoOpenTransaction&gt; {
		<span class="self">self</span>.close_transaction(<span class="bool-val">true</span>)
	}

	<span class="doccomment">/// Commit the last transaction started by `start_transaction`.
	///
	/// Any changes made during that transaction are committed. Returns an error if
	/// there is no open transaction that can be committed.
	</span><span class="kw">pub fn </span>commit_transaction(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), NoOpenTransaction&gt; {
		<span class="self">self</span>.close_transaction(<span class="bool-val">false</span>)
	}

	<span class="kw">fn </span>close_transaction(<span class="kw-2">&amp;mut </span><span class="self">self</span>, rollback: bool) -&gt; <span class="prelude-ty">Result</span>&lt;(), NoOpenTransaction&gt; {
		<span class="comment">// runtime is not allowed to close transactions started by the client
		</span><span class="kw">if let </span>ExecutionMode::Runtime = <span class="self">self</span>.execution_mode {
			<span class="kw">if </span>!<span class="self">self</span>.has_open_runtime_transactions() {
				<span class="kw">return </span><span class="prelude-val">Err</span>(NoOpenTransaction)
			}
		}

		<span class="kw">for </span>key <span class="kw">in </span><span class="self">self</span>.dirty_keys.pop().ok_or(NoOpenTransaction)<span class="question-mark">? </span>{
			<span class="kw">let </span>overlayed = <span class="self">self</span>.changes.get_mut(<span class="kw-2">&amp;</span>key).expect(
				<span class="string">&quot;\
				A write to an OverlayedValue is recorded in the dirty key set. Before an
				OverlayedValue is removed, its containing dirty set is removed. This
				function is only called for keys that are in the dirty set. qed\
			&quot;</span>,
			);

			<span class="kw">if </span>rollback {
				overlayed.pop_transaction();

				<span class="comment">// We need to remove the key as an `OverlayValue` with no transactions
				// violates its invariant of always having at least one transaction.
				</span><span class="kw">if </span>overlayed.transactions.is_empty() {
					<span class="self">self</span>.changes.remove(<span class="kw-2">&amp;</span>key);
				}
			} <span class="kw">else </span>{
				<span class="kw">let </span>has_predecessor = <span class="kw">if let </span><span class="prelude-val">Some</span>(dirty_keys) = <span class="self">self</span>.dirty_keys.last_mut() {
					<span class="comment">// Not the last tx: Did the previous tx write to this key?
					</span>!dirty_keys.insert(key)
				} <span class="kw">else </span>{
					<span class="comment">// Last tx: Is there already a value in the committed set?
					// Check against one rather than empty because the current tx is still
					// in the list as it is popped later in this function.
					</span>overlayed.transactions.len() &gt; <span class="number">1
				</span>};

				<span class="comment">// We only need to merge if there is an pre-existing value. It may be a value from
				// the previous transaction or a value committed without any open transaction.
				</span><span class="kw">if </span>has_predecessor {
					<span class="kw">let </span>dropped_tx = overlayed.pop_transaction();
					<span class="kw-2">*</span>overlayed.value_mut() = dropped_tx.value;
					overlayed.transaction_extrinsics_mut().extend(dropped_tx.extrinsics);
				}
			}
		}

		<span class="prelude-val">Ok</span>(())
	}

	<span class="kw">fn </span>has_open_runtime_transactions(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
		<span class="self">self</span>.transaction_depth() &gt; <span class="self">self</span>.num_client_transactions
	}
}

<span class="kw">impl </span>OverlayedChangeSet {
	<span class="doccomment">/// Get a mutable reference for a value.
	///
	/// Can be rolled back or committed when called inside a transaction.
	</span><span class="attribute">#[must_use = <span class="string">&quot;A change was registered, so this value MUST be modified.&quot;</span>]
	</span><span class="kw">pub fn </span>modify(
		<span class="kw-2">&amp;mut </span><span class="self">self</span>,
		key: StorageKey,
		init: <span class="kw">impl </span>Fn() -&gt; StorageValue,
		at_extrinsic: <span class="prelude-ty">Option</span>&lt;u32&gt;,
	) -&gt; <span class="kw-2">&amp;mut </span><span class="prelude-ty">Option</span>&lt;StorageValue&gt; {
		<span class="kw">let </span>overlayed = <span class="self">self</span>.changes.entry(key.clone()).or_default();
		<span class="kw">let </span>first_write_in_tx = insert_dirty(<span class="kw-2">&amp;mut </span><span class="self">self</span>.dirty_keys, key);
		<span class="kw">let </span>clone_into_new_tx = <span class="kw">if let </span><span class="prelude-val">Some</span>(tx) = overlayed.transactions.last() {
			<span class="kw">if </span>first_write_in_tx {
				<span class="prelude-val">Some</span>(tx.value.clone())
			} <span class="kw">else </span>{
				<span class="prelude-val">None
			</span>}
		} <span class="kw">else </span>{
			<span class="prelude-val">Some</span>(<span class="prelude-val">Some</span>(init()))
		};

		<span class="kw">if let </span><span class="prelude-val">Some</span>(cloned) = clone_into_new_tx {
			overlayed.set(cloned, first_write_in_tx, at_extrinsic);
		}
		overlayed.value_mut()
	}

	<span class="doccomment">/// Set all values to deleted which are matched by the predicate.
	///
	/// Can be rolled back or committed when called inside a transaction.
	</span><span class="kw">pub fn </span>clear_where(
		<span class="kw-2">&amp;mut </span><span class="self">self</span>,
		predicate: <span class="kw">impl </span>Fn(<span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>OverlayedValue) -&gt; bool,
		at_extrinsic: <span class="prelude-ty">Option</span>&lt;u32&gt;,
	) -&gt; u32 {
		<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
		<span class="kw">for </span>(key, val) <span class="kw">in </span><span class="self">self</span>.changes.iter_mut().filter(|(k, v)| predicate(k, v)) {
			<span class="kw">if </span>val.value_ref().is_some() {
				count += <span class="number">1</span>;
			}
			val.set(<span class="prelude-val">None</span>, insert_dirty(<span class="kw-2">&amp;mut </span><span class="self">self</span>.dirty_keys, key.clone()), at_extrinsic);
		}
		count
	}

	<span class="doccomment">/// Get the iterator over all changes that follow the supplied `key`.
	</span><span class="kw">pub fn </span>changes_after(<span class="kw-2">&amp;</span><span class="self">self</span>, key: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="kw">impl </span>Iterator&lt;Item = (<span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>OverlayedValue)&gt; {
		<span class="kw">use </span>sp_std::ops::Bound;
		<span class="kw">let </span>range = (Bound::Excluded(key), Bound::Unbounded);
		<span class="self">self</span>.changes.range::&lt;[u8], <span class="kw">_</span>&gt;(range).map(|(k, v)| (k.as_slice(), v))
	}
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>test {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="kw">use </span>pretty_assertions::assert_eq;

	<span class="kw">type </span>Changes&lt;<span class="lifetime">&#39;a</span>&gt; = Vec&lt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[u8], (<span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[u8]&gt;, Vec&lt;u32&gt;))&gt;;
	<span class="kw">type </span>Drained&lt;<span class="lifetime">&#39;a</span>&gt; = Vec&lt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[u8], <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[u8]&gt;)&gt;;

	<span class="kw">fn </span>assert_changes(is: <span class="kw-2">&amp;</span>OverlayedChangeSet, expected: <span class="kw-2">&amp;</span>Changes) {
		<span class="kw">let </span>is: Changes = is
			.changes()
			.map(|(k, v)| {
				(k.as_ref(), (v.value().map(AsRef::as_ref), v.extrinsics().into_iter().collect()))
			})
			.collect();
		<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>is, expected);
	}

	<span class="kw">fn </span>assert_drained_changes(is: OverlayedChangeSet, expected: Changes) {
		<span class="kw">let </span>is = is.drain_commited().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
		<span class="kw">let </span>expected = expected
			.iter()
			.map(|(k, v)| (k.to_vec(), v.<span class="number">0</span>.map(From::from)))
			.collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
		<span class="macro">assert_eq!</span>(is, expected);
	}

	<span class="kw">fn </span>assert_drained(is: OverlayedChangeSet, expected: Drained) {
		<span class="kw">let </span>is = is.drain_commited().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
		<span class="kw">let </span>expected = expected
			.iter()
			.map(|(k, v)| (k.to_vec(), v.map(From::from)))
			.collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
		<span class="macro">assert_eq!</span>(is, expected);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>no_transaction_works() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);

		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">2</span>));
		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0-1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">9</span>));

		assert_drained(changeset, <span class="macro">vec!</span>[(<span class="string">b&quot;key0&quot;</span>, <span class="prelude-val">Some</span>(<span class="string">b&quot;val0-1&quot;</span>)), (<span class="string">b&quot;key1&quot;</span>, <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>))]);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>transaction_works() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);

		<span class="comment">// no transaction: committed on set
		</span>changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0-1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">10</span>));

		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">1</span>);

		<span class="comment">// we will commit that later
		</span>changeset.set(<span class="string">b&quot;key42&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val42&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">42</span>));
		changeset.set(<span class="string">b&quot;key99&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val99&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">99</span>));

		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">2</span>);

		<span class="comment">// we will roll that back
		</span>changeset.set(<span class="string">b&quot;key42&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val42-rolled&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">421</span>));
		changeset.set(<span class="string">b&quot;key7&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val7-rolled&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">77</span>));
		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0-rolled&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1000</span>));
		changeset.set(<span class="string">b&quot;key5&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val5-rolled&quot;</span>.to_vec()), <span class="prelude-val">None</span>);

		<span class="comment">// changes contain all changes not only the commmited ones.
		</span><span class="kw">let </span>all_changes: Changes = <span class="macro">vec!</span>[
			(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0-rolled&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">10</span>, <span class="number">1000</span>])),
			(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>])),
			(<span class="string">b&quot;key42&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val42-rolled&quot;</span>), <span class="macro">vec!</span>[<span class="number">42</span>, <span class="number">421</span>])),
			(<span class="string">b&quot;key5&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val5-rolled&quot;</span>), <span class="macro">vec!</span>[])),
			(<span class="string">b&quot;key7&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val7-rolled&quot;</span>), <span class="macro">vec!</span>[<span class="number">77</span>])),
			(<span class="string">b&quot;key99&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val99&quot;</span>), <span class="macro">vec!</span>[<span class="number">99</span>])),
		];
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);

		<span class="comment">// this should be no-op
		</span>changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">3</span>);
		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">4</span>);
		changeset.rollback_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">3</span>);
		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">2</span>);
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);

		<span class="comment">// roll back our first transactions that actually contains something
		</span>changeset.rollback_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">1</span>);

		<span class="kw">let </span>rolled_back: Changes = <span class="macro">vec!</span>[
			(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0-1&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">10</span>])),
			(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>])),
			(<span class="string">b&quot;key42&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val42&quot;</span>), <span class="macro">vec!</span>[<span class="number">42</span>])),
			(<span class="string">b&quot;key99&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val99&quot;</span>), <span class="macro">vec!</span>[<span class="number">99</span>])),
		];
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>rolled_back);

		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>rolled_back);

		assert_drained_changes(changeset, rolled_back);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>transaction_commit_then_rollback_works() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);

		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0-1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">10</span>));

		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">1</span>);

		changeset.set(<span class="string">b&quot;key42&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val42&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">42</span>));
		changeset.set(<span class="string">b&quot;key99&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val99&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">99</span>));

		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">2</span>);

		changeset.set(<span class="string">b&quot;key42&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val42-rolled&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">421</span>));
		changeset.set(<span class="string">b&quot;key7&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val7-rolled&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">77</span>));
		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0-rolled&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1000</span>));
		changeset.set(<span class="string">b&quot;key5&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val5-rolled&quot;</span>.to_vec()), <span class="prelude-val">None</span>);

		<span class="kw">let </span>all_changes: Changes = <span class="macro">vec!</span>[
			(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0-rolled&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">10</span>, <span class="number">1000</span>])),
			(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>])),
			(<span class="string">b&quot;key42&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val42-rolled&quot;</span>), <span class="macro">vec!</span>[<span class="number">42</span>, <span class="number">421</span>])),
			(<span class="string">b&quot;key5&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val5-rolled&quot;</span>), <span class="macro">vec!</span>[])),
			(<span class="string">b&quot;key7&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val7-rolled&quot;</span>), <span class="macro">vec!</span>[<span class="number">77</span>])),
			(<span class="string">b&quot;key99&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val99&quot;</span>), <span class="macro">vec!</span>[<span class="number">99</span>])),
		];
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);

		<span class="comment">// this should be no-op
		</span>changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">3</span>);
		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">4</span>);
		changeset.rollback_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">3</span>);
		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">2</span>);
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);

		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">1</span>);

		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);

		changeset.rollback_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);

		<span class="kw">let </span>rolled_back: Changes =
			<span class="macro">vec!</span>[(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0-1&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">10</span>])), (<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>]))];
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>rolled_back);

		assert_drained_changes(changeset, rolled_back);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>modify_works() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);
		<span class="kw">let </span>init = || <span class="string">b&quot;valinit&quot;</span>.to_vec();

		<span class="comment">// committed set
		</span>changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">0</span>));
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="number">1</span>));
		<span class="kw">let </span>val = changeset.modify(<span class="string">b&quot;key3&quot;</span>.to_vec(), init, <span class="prelude-val">Some</span>(<span class="number">3</span>));
		<span class="macro">assert_eq!</span>(val, <span class="kw-2">&amp;</span><span class="prelude-val">Some</span>(<span class="string">b&quot;valinit&quot;</span>.to_vec()));
		val.as_mut().unwrap().extend_from_slice(<span class="string">b&quot;-modified&quot;</span>);

		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">1</span>);
		changeset.start_transaction();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">2</span>);

		<span class="comment">// non existing value -&gt; init value should be returned
		</span><span class="kw">let </span>val = changeset.modify(<span class="string">b&quot;key2&quot;</span>.to_vec(), init, <span class="prelude-val">Some</span>(<span class="number">2</span>));
		<span class="macro">assert_eq!</span>(val, <span class="kw-2">&amp;</span><span class="prelude-val">Some</span>(<span class="string">b&quot;valinit&quot;</span>.to_vec()));
		val.as_mut().unwrap().extend_from_slice(<span class="string">b&quot;-modified&quot;</span>);

		<span class="comment">// existing value should be returned by modify
		</span><span class="kw">let </span>val = changeset.modify(<span class="string">b&quot;key0&quot;</span>.to_vec(), init, <span class="prelude-val">Some</span>(<span class="number">10</span>));
		<span class="macro">assert_eq!</span>(val, <span class="kw-2">&amp;</span><span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()));
		val.as_mut().unwrap().extend_from_slice(<span class="string">b&quot;-modified&quot;</span>);

		<span class="comment">// should work for deleted keys
		</span><span class="kw">let </span>val = changeset.modify(<span class="string">b&quot;key1&quot;</span>.to_vec(), init, <span class="prelude-val">Some</span>(<span class="number">20</span>));
		<span class="macro">assert_eq!</span>(val, <span class="kw-2">&amp;</span><span class="prelude-val">None</span>);
		<span class="kw-2">*</span>val = <span class="prelude-val">Some</span>(<span class="string">b&quot;deleted-modified&quot;</span>.to_vec());

		<span class="kw">let </span>all_changes: Changes = <span class="macro">vec!</span>[
			(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0-modified&quot;</span>), <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">10</span>])),
			(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;deleted-modified&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">20</span>])),
			(<span class="string">b&quot;key2&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;valinit-modified&quot;</span>), <span class="macro">vec!</span>[<span class="number">2</span>])),
			(<span class="string">b&quot;key3&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;valinit-modified&quot;</span>), <span class="macro">vec!</span>[<span class="number">3</span>])),
		];
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);
		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">1</span>);
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>all_changes);

		changeset.rollback_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);
		<span class="kw">let </span>rolled_back: Changes = <span class="macro">vec!</span>[
			(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>), <span class="macro">vec!</span>[<span class="number">0</span>])),
			(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">None</span>, <span class="macro">vec!</span>[<span class="number">1</span>])),
			(<span class="string">b&quot;key3&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;valinit-modified&quot;</span>), <span class="macro">vec!</span>[<span class="number">3</span>])),
		];
		assert_changes(<span class="kw-2">&amp;</span>changeset, <span class="kw-2">&amp;</span>rolled_back);
		assert_drained_changes(changeset, rolled_back);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>clear_works() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();

		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">2</span>));
		changeset.set(<span class="string">b&quot;del1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;delval1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">3</span>));
		changeset.set(<span class="string">b&quot;del2&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;delval2&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">4</span>));

		changeset.start_transaction();

		changeset.clear_where(|k, <span class="kw">_</span>| k.starts_with(<span class="string">b&quot;del&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));

		assert_changes(
			<span class="kw-2">&amp;</span>changeset,
			<span class="kw-2">&amp;</span><span class="macro">vec!</span>[
				(<span class="string">b&quot;del1&quot;</span>, (<span class="prelude-val">None</span>, <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">5</span>])),
				(<span class="string">b&quot;del2&quot;</span>, (<span class="prelude-val">None</span>, <span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">5</span>])),
				(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>])),
				(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>), <span class="macro">vec!</span>[<span class="number">2</span>])),
			],
		);

		changeset.rollback_transaction().unwrap();

		assert_changes(
			<span class="kw-2">&amp;</span>changeset,
			<span class="kw-2">&amp;</span><span class="macro">vec!</span>[
				(<span class="string">b&quot;del1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;delval1&quot;</span>), <span class="macro">vec!</span>[<span class="number">3</span>])),
				(<span class="string">b&quot;del2&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;delval2&quot;</span>), <span class="macro">vec!</span>[<span class="number">4</span>])),
				(<span class="string">b&quot;key0&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>), <span class="macro">vec!</span>[<span class="number">1</span>])),
				(<span class="string">b&quot;key1&quot;</span>, (<span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>), <span class="macro">vec!</span>[<span class="number">2</span>])),
			],
		);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>next_change_works() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();

		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">0</span>));
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
		changeset.set(<span class="string">b&quot;key2&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val2&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">2</span>));

		changeset.start_transaction();

		changeset.set(<span class="string">b&quot;key3&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val3&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">3</span>));
		changeset.set(<span class="string">b&quot;key4&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val4&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">4</span>));
		changeset.set(<span class="string">b&quot;key11&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val11&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">11</span>));

		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key0&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key1&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key0&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val1&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key1&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key11&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key1&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val11&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key11&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key2&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key11&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val2&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key2&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key3&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key2&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val3&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key3&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key4&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key3&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val4&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key4&quot;</span>).next(), <span class="prelude-val">None</span>);

		changeset.rollback_transaction().unwrap();

		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key0&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key1&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key0&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val1&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key1&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key2&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key1&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val2&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key11&quot;</span>).next().unwrap().<span class="number">0</span>, <span class="string">b&quot;key2&quot;</span>);
		<span class="macro">assert_eq!</span>(
			changeset.changes_after(<span class="string">b&quot;key11&quot;</span>).next().unwrap().<span class="number">1</span>.value(),
			<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;val2&quot;</span>.to_vec())
		);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key2&quot;</span>).next(), <span class="prelude-val">None</span>);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key3&quot;</span>).next(), <span class="prelude-val">None</span>);
		<span class="macro">assert_eq!</span>(changeset.changes_after(<span class="string">b&quot;key4&quot;</span>).next(), <span class="prelude-val">None</span>);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>no_open_tx_commit_errors() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);
		<span class="macro">assert_eq!</span>(changeset.commit_transaction(), <span class="prelude-val">Err</span>(NoOpenTransaction));
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>no_open_tx_rollback_errors() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);
		<span class="macro">assert_eq!</span>(changeset.rollback_transaction(), <span class="prelude-val">Err</span>(NoOpenTransaction));
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>unbalanced_transactions_errors() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		changeset.start_transaction();
		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.commit_transaction(), <span class="prelude-val">Err</span>(NoOpenTransaction));
	}

	<span class="attribute">#[test]
	#[should_panic]
	</span><span class="kw">fn </span>drain_with_open_transaction_panics() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		changeset.start_transaction();
		<span class="kw">let _ </span>= changeset.drain_commited();
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>runtime_cannot_close_client_tx() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();
		changeset.start_transaction();
		changeset.enter_runtime().unwrap();
		changeset.start_transaction();
		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.commit_transaction(), <span class="prelude-val">Err</span>(NoOpenTransaction));
		<span class="macro">assert_eq!</span>(changeset.rollback_transaction(), <span class="prelude-val">Err</span>(NoOpenTransaction));
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>exit_runtime_closes_runtime_tx() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();

		changeset.start_transaction();

		changeset.set(<span class="string">b&quot;key0&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">1</span>));

		changeset.enter_runtime().unwrap();
		changeset.start_transaction();
		changeset.set(<span class="string">b&quot;key1&quot;</span>.to_vec(), <span class="prelude-val">Some</span>(<span class="string">b&quot;val1&quot;</span>.to_vec()), <span class="prelude-val">Some</span>(<span class="number">2</span>));
		changeset.exit_runtime().unwrap();

		changeset.commit_transaction().unwrap();
		<span class="macro">assert_eq!</span>(changeset.transaction_depth(), <span class="number">0</span>);

		assert_drained(changeset, <span class="macro">vec!</span>[(<span class="string">b&quot;key0&quot;</span>, <span class="prelude-val">Some</span>(<span class="string">b&quot;val0&quot;</span>))]);
	}

	<span class="attribute">#[test]
	</span><span class="kw">fn </span>enter_exit_runtime_fails_when_already_in_requested_mode() {
		<span class="kw">let </span><span class="kw-2">mut </span>changeset = OverlayedChangeSet::default();

		<span class="macro">assert_eq!</span>(changeset.exit_runtime(), <span class="prelude-val">Err</span>(NotInRuntime));
		<span class="macro">assert_eq!</span>(changeset.enter_runtime(), <span class="prelude-val">Ok</span>(()));
		<span class="macro">assert_eq!</span>(changeset.enter_runtime(), <span class="prelude-val">Err</span>(AlreadyInRuntime));
		<span class="macro">assert_eq!</span>(changeset.exit_runtime(), <span class="prelude-val">Ok</span>(()));
		<span class="macro">assert_eq!</span>(changeset.exit_runtime(), <span class="prelude-val">Err</span>(NotInRuntime));
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="sp_state_machine" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>